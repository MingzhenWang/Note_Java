<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第5章 继承](#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF)
  - [5.1 类、超类和子类](#51-%E7%B1%BB%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB)
    - [5.1.1 定义子类](#511-%E5%AE%9A%E4%B9%89%E5%AD%90%E7%B1%BB)
    - [5.1.2 覆盖方法](#512-%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95)
    - [5.1.3 子类构造器](#513-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8)
    - [5.1.4 继承层次](#514-%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1)
    - [5.1.5 多态](#515-%E5%A4%9A%E6%80%81)
    - [5.1.6 理解方法调用](#516-%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8)
    - [5.1.7 阻止继承：final类和方法](#517-%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BFfinal%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95)
    - [5.1.8 强制类型转换](#518-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)
    - [5.1.9 抽象类](#519-%E6%8A%BD%E8%B1%A1%E7%B1%BB)
    - [5.1.10 受保护访问](#5110-%E5%8F%97%E4%BF%9D%E6%8A%A4%E8%AE%BF%E9%97%AE)
  - [5.2 Object：所有类的超类](#52-object%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB)
    - [5.2.1 equals方法](#521-equals%E6%96%B9%E6%B3%95)
    - [5.2.2 相等测试与继承](#522-%E7%9B%B8%E7%AD%89%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%A7%E6%89%BF)
    - [5.2.3 hashCode方法](#523-hashcode%E6%96%B9%E6%B3%95)
    - [5.2.4 toString方法](#524-tostring%E6%96%B9%E6%B3%95)
  - [5.3 泛型数组列表](#53-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8)
  - [5.4 对象包装器与自动装箱](#54-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1)
  - [5.5 参数数量可变的方法](#55-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95)
  - [5.6 枚举类](#56-%E6%9E%9A%E4%B8%BE%E7%B1%BB)
  - [5.7 反射](#57-%E5%8F%8D%E5%B0%84)
  - [5.8 继承的设计技巧](#58-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->




## 第5章 继承
1、本章将学习面对对象程序设计的另外一个基本概念：继承（inheritance）。

* 利用继承，人们可以基于已存在的类构造一个新类。

* 继承已存在的类就是复用（继承）这些类的方法和域，在此基础上，可以添加一些新的方法和域，以满足新的需求。

2、另外，本章还阐述了反射（reflection）的概念。

**反射**：是指在程序运行期间发现更多的类及其属性的能力。

>这是一个功能强大的特性，使用起来也比较复杂。主要是开发软件工具的人员使用，编写应用程序的人很少用到。

### 5.1 类、超类和子类

>假设在某个公司工作，这个公司中经理的待遇与普通雇员的待遇存在着一些差异。不过， 他们之间也存在着很多相同的地方， 例如， 他们都领取薪水。只是普通雇员在完成本职任务之后仅领取薪水， 而经理在完成了预期的业绩之后还能得到奖金。这种情形就需要使用继承。这是因为需要为经理定义一个新类Manager, 以便增加一些新功能。但可以重用Employee 类中已经编写的部分代码，并将其中的所有域保留下来。

>从理论上讲， 在Manager 与Employee 之间存在着明显的“ isa”（是）关系， 每个经理都是一名雇员：“ is-a” 关系是继承的一个明显特征。

#### 5.1.1 定义子类
* 下面由继承Employee类来定义Manager类的格式，关键字extends表示继承
* Manager类自动继承了超类Employee类的方法和数据域

```java
public class Manager extends Employee
{
    添加方法和域
}
```
**extends**：表明正在构造的新类派生于一个已存在的类。
* 已存在的类称为**超类（superclass）**、基类（base class）或父类（parent class）；
* 新类称为**子类（subclass）**、派生类（derived class）或孩子类（child class）。


**如何扩展超类定义子类**
* 在通过扩展超类定义子类的时候，**仅需要指出子类与超类的不同之处**
* 在设计类的时候，应该将**通用的方法放在超类中**，将具有**特殊用途的方法放在子类中

#### 5.1.2 覆盖方法
* 超类中的有些方法对子类Manager并不一定适用。
>具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和，为此需要提供一个新的方法来覆盖（override）超类中的方法

>Manager类的getSalary方法不能直接访问超类的私有域，也就是说，尽管每个Manager类的方法一定要访问私有域，但在Manager类的getSalary方法不能直接访问私有域salary。

**只有Employee类的方法才能访问私有部分**

1. 如果Manager类的方法一定要访问私有域，就必须借助于公有的接口。Employee类中的公有方法getSalary正式这样一个接口。
2. 希望调用超类Employee中的getSalary方法，而不是当前类的方法，**使用特定的关键字super解决这个问题**

**子类如果要调用父类的私有方法，需要使用特定的关键字super**

Manager类中getSalary方法的正确书写格式：
```java
public double getSalary()
{
    double baseSalary = super.getSalary();
    return baseSalary = bonus;
}
```

#### 5.1.3 子类构造器
在例子最后，我们来提供一个构造器
```java
public Manager(String name, double salary, int year, int month,int day)
{
    super(name,salary,year,month,day);
    bonus = 0;
}
```
* 调用超类Employee中含有n、s、year、month和day参数的构造器 的简写形式
```java
super(name,salary,year,month,day);
```

>由于Manager类的构造器不能访问Employee类的私有域，必须利用Employee类的构造器对这部分私有域进行初始化。

我们可以通过super实现对超类构造器的调用。
**1、使用super调用构造器必须是子类构造器的第一条语句**

* 如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器
* 如果超类没有不带参数的构造器，且子类的构造器中没有显式地调用超类的其他构造器，则java编译器将报告错误。

**2、this和super关键字**
* **关键字this有两个用途**
  * 一是引用隐式参数
  * 二是调用该类其他的构造器。
* **super关键字有两个用途**
  * 一是调用超类的方法
  * 二是调用超类的构造器。

>这两个关键字的使用方式很相似：
1、调用构造器的语句只能作为另一个构造器的第一条语句出现
2、构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。

**3、多态**
* 一个对象变量可以指示多种实际类型的现象被称为**多态（polymorphism）**

```java
//创建一个新经理
Manager boss = new Manager("John",80000,1987,12,15);
//设置奖金
boss.setBonus(5000);
//定义一个包含3个雇员的数组
Employee[] staff = new Emplyee[3];
//将经理和雇员都放到数组中
staff[0] = boss;
staff[1] = new Employee("harry",50000,1989,10,1);
staff[2] = new Employee("tony",40000,1990,3,15);
//输出每个人的薪水
for(Employee e : staff)
{
  System.out.println(e.getName() + " " + e.getSalary());
}

```
>e.getSalary会自动调用Manager和Employee类的getSalary()方法，称之为多态


**4、动态绑定**
* 在运行时能够自动选择调用哪个方法的现象称为**动态绑定（dynamic binding）**。

#### 5.1.4 继承层次
* 继承并不仅限于一个层次。
>例如，Employee类派生出Manager类，由Manager类派生出Executive类。

**继承层次（inheritance hierarchy）**：由一个公共超类派生出来的所有类的集合。
**继承链（inheritance chain）**：在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。

>通常，一个祖先类可以拥有多个子孙继承链。


**多继承**：一个子类可以有多个父类，它继承了多个父类的特性

>注释：Java不支持多继承，Java中多继承功能的依靠接口实现。

#### 5.1.5 多态
**1、如何判断继承关系**
* 使用“is-a”规则，来判断是否应该设计为继承关系，它表明子类的每个对象也是超类的对象。
>例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之，不是每一名雇员都是经理。

* “is-a”规则的另一种表述法：置换法则，它表明程序中出现超类对象的任何地方都可以用子类对象置换。
>例如，可以将一个子类的对象赋给超类
```java
Employee e;
e = new Employee(...);
e = new Manager(...);
```
**2、在Java中，对象变量是多态的**
* 一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类对象。
```java
Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0] = boss;
```
>在上述例子中，变量staff[0]和boss引用同一个对象，但是编译器将staff[0]看做Employee对象，这意味着：
```java
boss.setBonus(5000);//正确
staff[0].setBonus(5000);//错误
```
>因为staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。

>不能将一个超类的引用赋给子类变量
```java
Manager m = staff[i];//错误
```

#### 5.1.6 理解方法调用
* 弄清楚如何在对象上应用方法调用非常重要。

>下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：

**1、编译器查看对象的声明类型和方法名**
>编译器获取所有可能被调用的候选方法
* 假设调用`x.f(param)`，且隐式参数x声明为C类的对象。注意：可能存在多个重载方法（名字相同参数类型不一样）。
* 编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。

**2、接下来，编译器将查看调用方法时提供的参数类型**
>编译器获取需要调用的方法名字和参数类型
* 如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析（overloading resolution）**。
* 如果没有找到与参数类型匹配的方法，或发现经过类型转换后有多个方法与之匹配，就会报一个错误。


>**方法的签名**：方法的名字和参数列表

>子类会覆盖超类中签名相同的方法。
不过，返回类型不是签名的一部分，因此，在覆盖方法时一定要保证返回类型的兼容性。
**可协变返回类型**：允许子类将覆盖方法的返回类型定义为原返回类型的子类型

**3、静态绑定（static binding）**
* 如果是private、static、final方法或者构造器，那么编译器将准确知道应该调用哪个方法，这种调用方式称为**静态绑定**。
* 与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**。

>在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f(String)的指令。

**4、动态绑定**
* 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与x 所引用对象的实际类型最合适的那个类的方法。
* 每次调用都要进行搜索，时间开支太大，因此虚拟机预先为每个类创建了一个**方法表（method table）**，其中列出了所有方法的签名和实际调用的方法。
* 真正调用方法时，虚拟机仅需要查找这个表
* 如果使用`super.f(param)`，编译器将对隐式参数超类的方法表做搜索

**动态绑定有一个非常重要的特性**： 无需对现存的代码进行修改，就可以对程序进行扩展。

假设增加一个新类Executive, 并且Employee对象变量e 有可能引用这个类的对象， 我们不需要对包含调用e.getSalary() 的代码进行重新编译。如果e 恰好引用一个Executive 类的对象， 就会自动地调用Executive.getSalaryO 方法。

>警告：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性

#### 5.1.7 阻止继承：final类和方法
**1、final类：不允许扩展的类**
* 如果在定义类的时候使用了final修饰符就表明这个类是final类，格式如下：
```java
public final class Executive extends MenuSelectionManager
{
    ...
}
```
* 类的特定方法被声明为final，子类就不能覆盖这个方法（final类中的所有方法自动地称为final方法）
```java
public class Employee
{
    public final String getName()
    {
        return name;
    }
}
```
>注释：**域也可以被声明为final**，final域构造对象之后不允许改变值。

>如果将一个类声明为final域，只有其中的方法自动地成为final，不包括域。

* **将方法或类声明为final 主要目的**： 确保它们不会在子类中改变语义。

>例如， Calendar类中的getTime 和setTime 方法都声明为final。这表明Calendar 类的设计者负责实现Date 类与日历状态之间的转换， 而不允许子类处理这些问题。

>同样地， String 类也是final 类，这意味着不允许任何人定义String 的子类。如果有一个String 的引用， 它引用的一定是一个String 对象， 而不可能是其他类的对象。

>在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。

**2、内联（inlining）**
* 如果一个方法没有被覆盖并且很短，编译器就能对它进行优化处理，这个过程称为内联。
>例如，内联调用e.getName()将被替换为访问e.Name域

* **内联的意义**：
  * 这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以被视为不受欢迎的。
* **内联的问题**：
  * 如果e.getName在另外一个类中被覆盖，那编译器无法知道覆盖的代码将做什么操作，因此不能对它进行内联处理。

* **内联问题的解决**：
  * 虚拟机中的即时编译器比传统的编译器的处理能力强得多，这种编译器可以准确知道类之间的继承关系，并能检测出类中是否真正存在覆盖给定的方法。
  * 如果方法很简短、被频繁调用且没有真正地被覆盖，即时编译器就会对这个方法进行内联处理。
  * 如果虚拟机加载了另外一个子类，包含了对内联方法的覆盖，优化器将取消对覆盖方法的内联，这个过程很慢，却很少发生。

#### 5.1.8 强制类型转换

**类型转换**：将一个类型强制转换成另外一个类型的过程

1、第3章中，Java提供了专门用于类型转换的表示法（基本数据类型）
```java
double x = 3.405;
int nx = (int)x;//将表达式x的值转换成整数类型，舍弃了小数部分
```

2、有时，需要将某个类的对象引用转换成另外一个类的对象引用，
**对象引用的转化语法**：用一对圆括号将目标类名括起来，并放在需要转换的对象引用之前：
```java
Manager boss = (Manager)staff[0];
```
**进行类型转换的唯一原因**：在暂时忽视对象的实际类型之后，使用对象的全部功能。

* 在Java 中， 每个对象变量都属于一个类型。
* 类型描述了这个变量所引用的以及能够引用的对象类型。

1、将一个子类的引用赋给一个超类变量，编译器是允许的；
2、将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。

* 如果不允许进行类型转换（超类的引用强制转换为子类的引用），Java运行时会产生ClassCastException异常。

* 因此类型转换前，先查看是否能够成功转换，使用instanceof操作符：
```java
if(staff[1] instanceof Manager)
{
    boss = (Manager)staff[1];
}
```
>如果staff[1]是null，会返回false，因为null没有引用任何对象，也不会引用Manager类型的对象。

综上所述：
* 只能在继承层次内进行类型转换
* 在超类转换成子类之前，应该使用instanceof进行检查

**一般情况下，尽量减少使用类型转换和instanceof操作符**

#### 5.1.9 抽象类
* 在自上而下的继承层次结构中，位于**上层的类更具有通用性、更加抽象**
* 祖先类更加通用，一般只将它作为派生其他类的基类，不作为想使用的特定的实例类。

已有Person类、Student类和Employee类，Person类为超类。一个雇员是一个人，一个学生也是一个人。

**1、为什么要花费精力进行更高层次的抽象？**
>每个人都有一些诸如姓名这样的属性。学生与雇员都有姓名属性， 因此可以将getName 方法放置在位于继承关系较高层次的通用超类中。

**2、抽象类**
>现在， 再增加一个getDescription 方法，它可以返回对一个人的简短描述。

>在Employee 类和Student 类中实现这个方法很容易。但是在Person 类中应该提供什么内容呢？ 除了姓名之外，Person 类一无所知。当然， 可以让Person.getDescription()返回一个空字符串。

（1）**使用abstract 关键字，这样就完全不需要实现这个方法**
```java
public abstract String getDescription();
```
（2）为了提高程序的清晰度，**包含一个或多个抽象方法的类本身必须被声明为抽象的**
```java
public abstract class person
{
    ...
    public abstract String getDescription();
}
```
（3）除了抽象方法之外， **抽象类还可以包含具体数据和具体方法**

>例如， Person 类还保存着姓名和一个返回姓名的具体方法。
```java
public abstract class person
{
    private String name;
    public Person(String name)
    {
        this.name = name;
    }
    public abstract String getDescription();
    public String getName()
    {
        return name;
    }
}
```
>**提示**：建议尽量将通用的域和方法（不管是否抽象）放在超类中（不管是否抽象）。

（4）**抽象方法充当着占位的角色，他们的具体实现在子类中**

**1、扩展抽象类可以有两种选择**：
* 在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类。
* 定义全部的抽象方法，这样子类就不是抽象的了。

**2、类就是不含抽象方法，也可以将类声明为抽象类**

**3、抽象类不能被实例化**

如果将一个类声明为abstract，就不能创建这个类的对象：
```java
New Person("TEST")//错误
```
>可以创建一个具体子类的对象

>可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象，例如：
```java
Person p = new Student("Vince Vu","Economic");
```


#### 5.1.10 受保护访问

* 最好将类中的域标记为private，方法标记为public

* 如果希望超类中的某些方法允许被子类访问，或者允许子类的方法访问超类的某个域，可以将这些方法或域声明为**protected**。

>例如，如果将超类Employee中的hireDay 声明为proteced，Manager 中的方法就可以直接地访问它。
不过， Manager 类中的方法只能够访问Manager 对象中的hireDay 域， 而不能访问其他Employee 对象中的这个域。

**1、谨慎使用protected 属性**

>假设需要将设计的类提供给其他程序员使用， 而在这个类中设置了一些受保护域

>由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。在这种情况下， 如果需要对这个类的实现进行修改， 就必须通知所有使用这个类的程序员。这违背了OOP 提倡的数据封装原则。

**2、受保护的方法更具有实际意义**
* 如果需要限制某个方法的使用， 就可以将它声明为protected。
* 这表明子类（可能很熟悉祖先类）得到信任， 可以正确地使用这个方法， 而其他类则不行。

>这种方法的一个最好的示例就是Object 类中的clone 方法， 有关它的详细内容请参看第6 章。

**3、归纳Java中控制可见性的4个访问修饰符**
* private
  * 仅对本类可见
* public
  * 对所有类可见
* protected
  * 对本包和所有子类可见
* 默认，不需要修饰符
  * 对本包可见

### 5.2 Object：所有类的超类

* **Object 类是Java 中所有类的始祖**，在Java中每个类都是由它扩展而来的，如果没有明确地指出超类，Object就是这个类的超类

1、可以使用Object类型的变量引用任何类型的变量：
```java
Object obj = new Employee("Harry Hacker",35000);
```
* Object类型的变量只能用于作为各种值的通用持有者，要想对其中的内容进行具体操作，还要清楚对象的原始类型，并进行类型转换：
```java
Employee e = (Employee) obj;
```
2、在Java中，只有基本类型（primitive types）不是对象

>例如，数值、字符和布尔类型的值都不是对象。
所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。

```java
Employee[] staff = new Employee[10];
obj = staff;//OK
obj = new int[10];//OK
```
#### 5.2.1 equals方法
>Object类中的equals方法用于检测一个对象是否等于另外一个对象。这个方法用于判断**两个对象是否具有相同的引用**。

* 如果两个对象具有相同的引用，那它们一定是相等的

如下示例演示equals方法的实现机制：
```java
public class Employee
{
    public boolean equals(Object otherObject)
    {
        //a quick test to see if the objects are identical
        if(this == otherObject) return true;
        //must return false if the explicit parameter is null
        if(otherObject == null) return false;
        //if the classes don't match, they can't be equal
        if(getClass() != otherObject.getClass()) return false;
        
        //now we know otherObject is a non-null Employee
        Employee other = (Employee)otherObject;
        
        //test whether the fields have identical values
         return name.equals(other.name)
                 && salary == other.salary
                 && hireDay.equals(other.hireDay);
    }
}

```
>getClass方法返回一个对象所属的类。只有两个对象属于同一个类时，才会相等。

>提示：为了防备name或hireDay 可能为null 的情况， 需要使用Objects.equals 方法。
>如果两个参数都为null, Objects.equals(a, b) 调用将返回true ; 
>如果其中一个参数为null,则返回false; 
>否则， 如果两个参数都不为null, 则调用a.equals(b)。
利用这个方法，Employee.equals 方法的最后一条语句要改写为：
```java
return Objects.equals(name, other.name)
&& salary== other.salary
&& Object.equals(hireDay, other.hireDay);
```

在子类中定义equals 方法时， 首先调用超类的equals。如果检测失败， 对象就不可能相等。如果超类中的域都相等， 就需要比较子类中的实例域。

```java
public class Manager extends Employee
{
    public boolean equals(Object otherObject)
    {
        if(!super.equals(otherObject)) return false;
        //super.equals checked that this and otherObject belong to the same class
        Manager other = (Manager)otherObject;
        return bonus == other.bonus;
    }
}
```
#### 5.2.2 相等测试与继承

Java语言规范要求equals方法具有以下特性：
* **自反性**：对于任何非空引用x，x.equals(x)应该返回true；
* **对称性**：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true；
* **传递性**：对于任何引用x、y、和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true；
* **一致性**：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果；
* 对于任意非空引用x，x.equals(null)返回false。

**如果隐式和显示的参数不属于同一个类，equals方法将如何处理？**

**1、不推荐使用instanceof方法进行检测**：

**不符合对称性原则**
```java
if(!(otherObject instanceof Employee)) return false;
```
这样不仅没有解决otherObject是子类的情况，并且还有可能会招惹一些麻烦，例如：

>就**对称性**而言，当参数不属于同一个类时，需要仔细思考:

>e是Employee对象，m是一个Manager对象，并且这两个类具有相同的姓名、薪水和雇用日期。

>如果在Employee.equals中用instanceof 进行检测， 则返回true；然而这意味着反过来调用m.equals(e)  也需要返回true。对称性不允许这个方法调用返回false或抛出异常。

>这就使得Manager 类受到了束缚。这个类的equals 方法必须能够用自己与任何一个Employee 对象进行比较， 而不考虑经理拥有的那部分特有信息。因此instanceof 测试并不是完美无瑕。

**2、有些人认为不应该使用getClass检测**

**因为这不符合置换原则**

>有一个应用AbstractSet 类的equals 方法的典型例子， 它将检测两个集合是否有相同的元素。

>AbstractSet类有两个具体子类： TreeSet 和HashSet, 它们分别使用不同的算法实现查找集合元素的操作。

>无论集合采用何种方式实现， 都需要拥有对任意两个集合进行比较的功能，此时**如果使用getClass()方法，得到的超类都是一样的，然而其对应子类是不一致的**。

然而， 集合是相当特殊的一个例子， 应该将`AbstractSet.equals`声明为final , 这是因为没有任何一个子类需要重定义集合是否相等的语义。不需要继承AbstractSet类

>（事实上， 这个方法并没有被声明为final。这样做， 可以让子类选择更加有效的算法对集合进行是否相等的检测）

**3、下面可以从两个截然不同的情况看一下这个问题**：

* 如果子类能够拥有自己的相等概念， 则对称性需求将强制采用getClass 进行检测
* 如果由超类决定相等的概念，那么就可以使用instanceof 进行检测， 这样可以在不同子类的对象之间进行相等的比较。

1、在雇员和经理的例子中， 只要对应的域相等， 就认为两个对象相等。

>如果两个Manager对象所对应的姓名、薪水和雇佣日期均相等， 而奖金不相等， 就认为它们是不相同的， 因此， 可以使用getClass 检测。

>但是， 假设使用雇员的ID 作为相等的检测标准， 并且这个相等的概念适用于所有的子类， 就可以使用instanceof 进行检测， 并应该将Employee.equals 声明为final。

>**注释**：在标准Java 库中包含150 多个equals 方法的实现， 包括使用instanceof 检测、调用getClass 检测、捕获ClassCastException 或者什么也不做。

>可以查看java.sql.Timestamp 类的API 文档， 在这里实现人员不无尴尬地指出， 他们使自己陷入了困境。Timestamp 类继承自java.util.Date， 而后者的equals 方法使用了一个instanceof 测试， 这样一来就无法覆盖实现equals 使之同时做到对称且正确。

**下面给出一个编写完美equals方法的建议**：
（1）显式参数命名为otherObject，稍后需要将它转换成另一个叫other的变量
（2）检测this与otherObject是否引用同一个对象：
```java
if(this==otherObject) return true;
```
>这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。

（3）检测otherObject是否为null，如果为null，返回false
```java
if(otherObject = null) return false;
```
（4）比较this与otherObject是否属于同一个类。
* 如果equals的语义在每个子类中有所改变，就使用getClass检测：
```java
if(getClass() != otherObject.getCIass()) return false;
```
* 如果所有的子类都拥有统一的语义，就使用instanceof 检测：
```java
if(!(otherObject instanceof ClassName)) return false;
```
（5） 将otherObject 转换为相应的类类型变量：
```java
ClassName other = (ClassName)otherObject;
```
（6）现在开始对所有需要比较的域进行比较了。
* 使用`==`比较基本类型域，使用equals 比较对象域。如果所有的域都匹配， 就返回true; 否则返回false。
```java
return field1==other.field1 && Objects.equals(field2,other.field2);
```
>如果在子类中重新定义equals，就要在其中包含super.equals(other);

>注意：对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。
```java
API java.util.Arrays 1.2
    static Boolean equals(type[] a, type[] b) 5.0
	    如果两个数组长度相同，并且在对应的位置上数据元素也均相同，将返回true。数组的元素类型可以是Object、int、long、short、char、byte、boolean、float 或double。
API java.util.Objects 7
    static boolean equals(Object a, Object b)
	    如果a和b都为null，返回true; 如果只有其中之一为null，则返回false; 否则返回a.equals(b)。
```

#### 5.2.3 hashCode方法
**散列码（hash code）**：是由对象导出的一个整型值。散列码是没有规律的。

>如果x 和y 是两个不同的对象， x.hashCode() 与y.hashCode() 基本上不会相同。

1、String类使用下列算法计算散列码：
```java
int hash = 0;
for(int i=0;i < length(); i++)
{
    hash = 31*hash+charAt(i);
}
```
2、由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。
```java
String s = "OK";
StringBuilder sb = new StringBuilder(s);
System.out.println(s.hashCode() + " " + sb.hashCode());
String t = new String("OK");
StringBuilder tb = new StringBuilder(t);
System.out.println(t.hashCode() + " " + tb.hashCode());
```

结果如下：
![](/001-Java核心技术_卷一/Pictures/5001.jpeg)

>字符串s 与t 拥有相同的散列码， 这是因为字符串的散列码是由内容导出的。

>而字符串缓冲sb 与tb 却有着不同的散列码， 这是因为在StringBuffer 类中没有定义hashCode 方法，它的散列码是由Object 类的默认hashCode 方法导出的对象存储地址。

**如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中**

3、hashCode方法应该返回一个整型数值（也可以是负数），并合理地组合实例域的散列码，以便能让各个不同的对象产生的散列码更加均匀。

>例如，下面是Employee类的hashCode方法
```java
public class Employee()
{
    public int hashCode()
    {
        return 7*name.hashCode()+11*new double(salary).hashCode()+13*hireDay.hashCode();
    }
}
```
>进一步优化，使用null安全的方法`Objects.hashCode`。如果其参数为null，这个方法会返回0。另外使用静态方法`Double.hashCode`来避免创建Double对象：
```java
public int hashCode()
{
    return 7*Objects.hashCode(name)+11*Double.hashCode(salary)+13*Objects.hashCode(hireDay);
}
```
>再进一步优化，需要组合多个散列值时，可以调用Objects.hash 并提供多个参数。这个方法会对各个参数调Objects.hashCode， 并组合这些散列值。
```java
public int hashCode()
{
    return Objects.hash(name,salary,hireDay);
}
```
**Equals 与hashCode 的定义必须一致**
* 如果x.equals(y) 返回true,那么`x.hashCode()`就必须与`y.hashCode()`具有相同的值。

>如果存在数组类型的域，那么可以使用静态的Arrays.hashCode 方法计算一个散列码，这个散列码由数组元素的散列码组成。

```java
API java.util.Object 1.0
	int hashCode()
		返回对象的散列码。散列码可以是任意的整数，包括正数或负数。两个相等的对象要求返回相等的散列码。
API java.util.Objects 7
	static int hash(Object . . . objects)
		返回一个散列码，由提供的所有对象的散列码组合而得到。
	static int hashCode(Object a)
		○ 如果a为null返回0，否则返回a.hashCode()。
API java.lang.(lnteger|Long|Short|Byte|Double|Float|Character|Boolean) 1.0
	static int hashCode((int|long|short|byte|double|float|char|boolean) value) 8
		返回给定值的散列码。
API java.util.Arrays 1.2
	static int hashCode(type[] a) 5.0
		○ 计算数组a的散列码。组成这个数组的元素类型可以是object，int，long，short，char，byte，boolean，float或double。
```

#### 5.2.4 toString方法

* 在Object中还有一个重要的方法，toString方法。toString方法用于返回表示对象值的字符串。

>Point类的toString方法将返回下面这样的字符串：
```java
java.awt.Point[x=10，y=20]
```
**toString方法的格式**
* 绝大多数（但不是全部）的toString 方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。

>如下，是Employee类的toString方法的实现：
```java
public String toString()
{
    return "Employee[name="+name
        +",slalry="+salary
        +",hireDay="+hireDay
        +"]";
}
```
>进一步优化，通过调用getClass().getName()获得类名的字符串，不要将类名硬加到toString方法中。
```java
public String toString()
{
    return getClass().getName()
        +"[name="+name
        +",slalry="+salary
        +",hireDay="+hireDay
        +"]";
}
```
>如果超类使用了getClass().getName(), 那么子类只要调用super.toString() 就可以了。例如，
```java
public class Manager extends Employee
{
    public String toString()
    {
        return super.toString()
            +"[bonus="+bonus
            +"]";
    }
}
```

**随处可见toString 方法的主要原因是：**
* 只要对象与一个字符串通过操作符“ +” 连接起来，Java 编译就会自动地调用toString 方法，以便获得这个对象的字符串描述。
```java
Point p = new Point(10,20);
String message = "The current position is "+p;
//automatically invokes p.toString()
```
>提示：在调用x.toString( ) 的地方可以用`""+x`替代。这条语句将一个空串与x 的字符串表示相连接。这里的x 就是x.toString( )。 与toString 不同的是， 如果x 是基本类型， 这条语句照样能够执行。

* 如果x 是任意一个对象， 并调用`System.out.println(x)`；println 方法就会直接地调用x.toString()，井打印输出得到的字符串。
* Object 类定义了toString 方法， 用来打印输出**对象所属的类名和散列码**。

>例如， 调用`System.out.println(System.out)`，将输出：`java.io.PrintStream@6bc7c054`
之所以得到这样的结果是因为PrintStream 类的设计者没有覆盖toString 方法。

**警告**：数组继承了object 类的toString 方法， 数组类型将按照旧的格式打印。
>例如：如下生成字符串，[I@6bc7c054，I表示整型数组
int[] luckyNumbers = {2,3,5,7,11,13};
String s = "" + luckyNumbers;

**修正**：调用静态方法`Array.toString()`，将生成字符串[2, 3, 5, 7, 11, 13]
要想打印多维数组（即，数组的数组）则需要调用`Arrays.deepToString`方法。

**toString 方法是一种非常有用的调试工具**
>在标准类库中，许多类都定义了toString 方法， 以便用户能够获得一些有关对象状态的必要信息。像下面这样显示调试信息非常有益：
```java
System,out.println("Current position = " + position);
```
读者在第7 章中将可以看到，更好的解决方法是：
```java
Logger.global.info("Current position = " + position);
```

>提示： 强烈建议为自定义的每一个类增加toString 方法。这样做不仅自己受益， 而且所有使用这个类的程序员也会从这个日志记录支持中受益匪浅。

```java
API java.lang.Object 1.0
    Class getClass()
        返回包含对象信息的类对象。稍后会看到Java 提供了类运行时的描述，它的内容被封装在Class 类中。
    boolean equals(Object otherObject)
        比较两个对象是否相等， 如果两个对象指向同一块存储区域，方法返回true ; 否则方法返回false。在自定义的类中， 应该覆盖这个方法.
    String toString()
        返冋描述该对象值的字符串。在自定义的类中， 应该覆盖这个方法。
API java.lang.Class 1.0
    String getName()
        返回这个类的名字。
    Class getSuperclass()
        以Class对象的形式返回这个类的超类信息。
```

### 5.3 泛型数组列表

### 5.4 对象包装器与自动装箱

### 5.5 参数数量可变的方法


### 5.6 枚举类


### 5.7 反射

### 5.8 继承的设计技巧

