<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第5章 继承](#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF)
  - [5.1 类、超类和子类](#51-%E7%B1%BB%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB)
    - [5.1.1 定义子类](#511-%E5%AE%9A%E4%B9%89%E5%AD%90%E7%B1%BB)
    - [5.1.2 覆盖方法](#512-%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95)
    - [5.1.3 子类构造器](#513-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8)
    - [5.1.4 继承层次](#514-%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1)
    - [5.1.5 多态](#515-%E5%A4%9A%E6%80%81)
    - [5.1.6 理解方法调用](#516-%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8)
    - [5.1.7 阻止继承：final类和方法](#517-%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BFfinal%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95)
    - [5.1.8 强制类型转换](#518-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)
    - [5.1.9 抽象类](#519-%E6%8A%BD%E8%B1%A1%E7%B1%BB)
    - [5.1.10 受保护访问](#5110-%E5%8F%97%E4%BF%9D%E6%8A%A4%E8%AE%BF%E9%97%AE)
  - [5.2 Object：所有类的超类](#52-object%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB)
    - [5.2.1 equals方法](#521-equals%E6%96%B9%E6%B3%95)
    - [5.2.2 相等测试与继承](#522-%E7%9B%B8%E7%AD%89%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%A7%E6%89%BF)
    - [5.2.3 hashCode方法](#523-hashcode%E6%96%B9%E6%B3%95)
    - [5.2.4 toString方法](#524-tostring%E6%96%B9%E6%B3%95)
  - [5.3 泛型数组列表](#53-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8)
    - [5.3.1 访问数组列表元素](#531-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0)
    - [5.3.2 类型化与原始数组列表的兼容性](#532-%E7%B1%BB%E5%9E%8B%E5%8C%96%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7)
  - [5.4 对象包装器与自动装箱](#54-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1)
  - [5.5 参数数量可变的方法](#55-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95)
  - [5.6 枚举类](#56-%E6%9E%9A%E4%B8%BE%E7%B1%BB)
  - [5.7 反射](#57-%E5%8F%8D%E5%B0%84)
    - [5.7.1 Class类](#571-class%E7%B1%BB)
    - [5.7.2 捕获异常](#572-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8)
    - [5.7.3 利用反射分析类的能力](#573-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E7%B1%BB%E7%9A%84%E8%83%BD%E5%8A%9B)
    - [5.7.4 在运行时使用反射分析对象](#574-%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1)
    - [5.7.5 使用反射编写泛型数组代码](#575-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81)
    - [5.7.6 调用任意方法](#576-%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95)
  - [5.8 继承的设计技巧](#58-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->




## 第5章 继承
1、本章将学习面对对象程序设计的另外一个基本概念：继承（inheritance）。

* 利用继承，人们可以基于已存在的类构造一个新类。

* 继承已存在的类就是复用（继承）这些类的方法和域，在此基础上，可以添加一些新的方法和域，以满足新的需求。

2、另外，本章还阐述了反射（reflection）的概念。

**反射**：是指在程序运行期间发现更多的类及其属性的能力。

>这是一个功能强大的特性，使用起来也比较复杂。主要是开发软件工具的人员使用，编写应用程序的人很少用到。

### 5.1 类、超类和子类

>假设在某个公司工作，这个公司中经理的待遇与普通雇员的待遇存在着一些差异。不过， 他们之间也存在着很多相同的地方， 例如， 他们都领取薪水。只是普通雇员在完成本职任务之后仅领取薪水， 而经理在完成了预期的业绩之后还能得到奖金。这种情形就需要使用继承。这是因为需要为经理定义一个新类Manager, 以便增加一些新功能。但可以重用Employee 类中已经编写的部分代码，并将其中的所有域保留下来。

>从理论上讲， 在Manager 与Employee 之间存在着明显的“ isa”（是）关系， 每个经理都是一名雇员：“ is-a” 关系是继承的一个明显特征。

#### 5.1.1 定义子类
* 下面由继承Employee类来定义Manager类的格式，关键字extends表示继承
* Manager类自动继承了超类Employee类的方法和数据域

```java
public class Manager extends Employee
{
    添加方法和域
}
```
**extends**：表明正在构造的新类派生于一个已存在的类。
* 已存在的类称为**超类（superclass）**、基类（base class）或父类（parent class）；
* 新类称为**子类（subclass）**、派生类（derived class）或孩子类（child class）。


**如何扩展超类定义子类**
* 在通过扩展超类定义子类的时候，**仅需要指出子类与超类的不同之处**
* 在设计类的时候，应该将**通用的方法放在超类中**，将具有**特殊用途的方法放在子类中

#### 5.1.2 覆盖方法
* 超类中的有些方法对子类Manager并不一定适用。
>具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和，为此需要提供一个新的方法来覆盖（override）超类中的方法

>Manager类的getSalary方法不能直接访问超类的私有域，也就是说，尽管每个Manager类的方法一定要访问私有域，但在Manager类的getSalary方法不能直接访问私有域salary。

**只有Employee类的方法才能访问私有部分**

1. 如果Manager类的方法一定要访问私有域，就必须借助于公有的接口。Employee类中的公有方法getSalary正式这样一个接口。
2. 希望调用超类Employee中的getSalary方法，而不是当前类的方法，**使用特定的关键字super解决这个问题**

**子类如果要调用父类的私有方法，需要使用特定的关键字super**

Manager类中getSalary方法的正确书写格式：
```java
public double getSalary()
{
    double baseSalary = super.getSalary();
    return baseSalary = bonus;
}
```

#### 5.1.3 子类构造器
在例子最后，我们来提供一个构造器
```java
public Manager(String name, double salary, int year, int month,int day)
{
    super(name,salary,year,month,day);
    bonus = 0;
}
```
* 调用超类Employee中含有n、s、year、month和day参数的构造器 的简写形式
```java
super(name,salary,year,month,day);
```

>由于Manager类的构造器不能访问Employee类的私有域，必须利用Employee类的构造器对这部分私有域进行初始化。

我们可以通过super实现对超类构造器的调用。
**1、使用super调用构造器必须是子类构造器的第一条语句**

* 如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器
* 如果超类没有不带参数的构造器，且子类的构造器中没有显式地调用超类的其他构造器，则java编译器将报告错误。

**2、this和super关键字**
* **关键字this有两个用途**
  * 一是引用隐式参数
  * 二是调用该类其他的构造器。
* **super关键字有两个用途**
  * 一是调用超类的方法
  * 二是调用超类的构造器。

>这两个关键字的使用方式很相似：
1、调用构造器的语句只能作为另一个构造器的第一条语句出现
2、构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。

**3、多态**
* 一个对象变量可以指示多种实际类型的现象被称为**多态（polymorphism）**

```java
//创建一个新经理
Manager boss = new Manager("John",80000,1987,12,15);
//设置奖金
boss.setBonus(5000);
//定义一个包含3个雇员的数组
Employee[] staff = new Emplyee[3];
//将经理和雇员都放到数组中
staff[0] = boss;
staff[1] = new Employee("harry",50000,1989,10,1);
staff[2] = new Employee("tony",40000,1990,3,15);
//输出每个人的薪水
for(Employee e : staff)
{
  System.out.println(e.getName() + " " + e.getSalary());
}

```
>e.getSalary会自动调用Manager和Employee类的getSalary()方法，称之为多态


**4、动态绑定**
* 在运行时能够自动选择调用哪个方法的现象称为**动态绑定（dynamic binding）**。

#### 5.1.4 继承层次
* 继承并不仅限于一个层次。
>例如，Employee类派生出Manager类，由Manager类派生出Executive类。

**继承层次（inheritance hierarchy）**：由一个公共超类派生出来的所有类的集合。
**继承链（inheritance chain）**：在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。

>通常，一个祖先类可以拥有多个子孙继承链。


**多继承**：一个子类可以有多个父类，它继承了多个父类的特性

>注释：Java不支持多继承，Java中多继承功能的依靠接口实现。

#### 5.1.5 多态
**1、如何判断继承关系**
* 使用“is-a”规则，来判断是否应该设计为继承关系，它表明子类的每个对象也是超类的对象。
>例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之，不是每一名雇员都是经理。

* “is-a”规则的另一种表述法：置换法则，它表明程序中出现超类对象的任何地方都可以用子类对象置换。
>例如，可以将一个子类的对象赋给超类
```java
Employee e;
e = new Employee(...);
e = new Manager(...);
```
**2、在Java中，对象变量是多态的**
* 一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类对象。
```java
Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0] = boss;
```
>在上述例子中，变量staff[0]和boss引用同一个对象，但是编译器将staff[0]看做Employee对象，这意味着：
```java
boss.setBonus(5000);//正确
staff[0].setBonus(5000);//错误
```
>因为staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。

>不能将一个超类的引用赋给子类变量
```java
Manager m = staff[i];//错误
```

#### 5.1.6 理解方法调用
* 弄清楚如何在对象上应用方法调用非常重要。

>下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：

**1、编译器查看对象的声明类型和方法名**
>编译器获取所有可能被调用的候选方法
* 假设调用`x.f(param)`，且隐式参数x声明为C类的对象。注意：可能存在多个重载方法（名字相同参数类型不一样）。
* 编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。

**2、接下来，编译器将查看调用方法时提供的参数类型**
>编译器获取需要调用的方法名字和参数类型
* 如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析（overloading resolution）**。
* 如果没有找到与参数类型匹配的方法，或发现经过类型转换后有多个方法与之匹配，就会报一个错误。


>**方法的签名**：方法的名字和参数列表

>子类会覆盖超类中签名相同的方法。
不过，返回类型不是签名的一部分，因此，在覆盖方法时一定要保证返回类型的兼容性。
**可协变返回类型**：允许子类将覆盖方法的返回类型定义为原返回类型的子类型

**3、静态绑定（static binding）**
* 如果是private、static、final方法或者构造器，那么编译器将准确知道应该调用哪个方法，这种调用方式称为**静态绑定**。
* 与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**。

>在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f(String)的指令。

**4、动态绑定**
* 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与x 所引用对象的实际类型最合适的那个类的方法。
* 每次调用都要进行搜索，时间开支太大，因此虚拟机预先为每个类创建了一个**方法表（method table）**，其中列出了所有方法的签名和实际调用的方法。
* 真正调用方法时，虚拟机仅需要查找这个表
* 如果使用`super.f(param)`，编译器将对隐式参数超类的方法表做搜索

**动态绑定有一个非常重要的特性**： 无需对现存的代码进行修改，就可以对程序进行扩展。

假设增加一个新类Executive, 并且Employee对象变量e 有可能引用这个类的对象， 我们不需要对包含调用e.getSalary() 的代码进行重新编译。如果e 恰好引用一个Executive 类的对象， 就会自动地调用Executive.getSalaryO 方法。

>警告：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性

#### 5.1.7 阻止继承：final类和方法
**1、final类：不允许扩展的类**
* 如果在定义类的时候使用了final修饰符就表明这个类是final类，格式如下：
```java
public final class Executive extends MenuSelectionManager
{
    ...
}
```
* 类的特定方法被声明为final，子类就不能覆盖这个方法（final类中的所有方法自动地称为final方法）
```java
public class Employee
{
    public final String getName()
    {
        return name;
    }
}
```
>注释：**域也可以被声明为final**，final域构造对象之后不允许改变值。

>如果将一个类声明为final域，只有其中的方法自动地成为final，不包括域。

* **将方法或类声明为final 主要目的**： 确保它们不会在子类中改变语义。

>例如， Calendar类中的getTime 和setTime 方法都声明为final。这表明Calendar 类的设计者负责实现Date 类与日历状态之间的转换， 而不允许子类处理这些问题。

>同样地， String 类也是final 类，这意味着不允许任何人定义String 的子类。如果有一个String 的引用， 它引用的一定是一个String 对象， 而不可能是其他类的对象。

>在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。

**2、内联（inlining）**
* 如果一个方法没有被覆盖并且很短，编译器就能对它进行优化处理，这个过程称为内联。
>例如，内联调用e.getName()将被替换为访问e.Name域

* **内联的意义**：
  * 这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以被视为不受欢迎的。
* **内联的问题**：
  * 如果e.getName在另外一个类中被覆盖，那编译器无法知道覆盖的代码将做什么操作，因此不能对它进行内联处理。

* **内联问题的解决**：
  * 虚拟机中的即时编译器比传统的编译器的处理能力强得多，这种编译器可以准确知道类之间的继承关系，并能检测出类中是否真正存在覆盖给定的方法。
  * 如果方法很简短、被频繁调用且没有真正地被覆盖，即时编译器就会对这个方法进行内联处理。
  * 如果虚拟机加载了另外一个子类，包含了对内联方法的覆盖，优化器将取消对覆盖方法的内联，这个过程很慢，却很少发生。

#### 5.1.8 强制类型转换

**类型转换**：将一个类型强制转换成另外一个类型的过程

1、第3章中，Java提供了专门用于类型转换的表示法（基本数据类型）
```java
double x = 3.405;
int nx = (int)x;//将表达式x的值转换成整数类型，舍弃了小数部分
```

2、有时，需要将某个类的对象引用转换成另外一个类的对象引用，
**对象引用的转化语法**：用一对圆括号将目标类名括起来，并放在需要转换的对象引用之前：
```java
Manager boss = (Manager)staff[0];
```
**进行类型转换的唯一原因**：在暂时忽视对象的实际类型之后，使用对象的全部功能。

* 在Java 中， 每个对象变量都属于一个类型。
* 类型描述了这个变量所引用的以及能够引用的对象类型。

1、将一个子类的引用赋给一个超类变量，编译器是允许的；
2、将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。

* 如果不允许进行类型转换（超类的引用强制转换为子类的引用），Java运行时会产生ClassCastException异常。

* 因此类型转换前，先查看是否能够成功转换，使用instanceof操作符：
```java
if(staff[1] instanceof Manager)
{
    boss = (Manager)staff[1];
}
```
>如果staff[1]是null，会返回false，因为null没有引用任何对象，也不会引用Manager类型的对象。

综上所述：
* 只能在继承层次内进行类型转换
* 在超类转换成子类之前，应该使用instanceof进行检查

**一般情况下，尽量减少使用类型转换和instanceof操作符**

#### 5.1.9 抽象类
* 在自上而下的继承层次结构中，位于**上层的类更具有通用性、更加抽象**
* 祖先类更加通用，一般只将它作为派生其他类的基类，不作为想使用的特定的实例类。

已有Person类、Student类和Employee类，Person类为超类。一个雇员是一个人，一个学生也是一个人。

**1、为什么要花费精力进行更高层次的抽象？**
>每个人都有一些诸如姓名这样的属性。学生与雇员都有姓名属性， 因此可以将getName 方法放置在位于继承关系较高层次的通用超类中。

**2、抽象类**
>现在， 再增加一个getDescription 方法，它可以返回对一个人的简短描述。

>在Employee 类和Student 类中实现这个方法很容易。但是在Person 类中应该提供什么内容呢？ 除了姓名之外，Person 类一无所知。当然， 可以让Person.getDescription()返回一个空字符串。

（1）**使用abstract 关键字，这样就完全不需要实现这个方法**
```java
public abstract String getDescription();
```
（2）为了提高程序的清晰度，**包含一个或多个抽象方法的类本身必须被声明为抽象的**
```java
public abstract class person
{
    ...
    public abstract String getDescription();
}
```
（3）除了抽象方法之外， **抽象类还可以包含具体数据和具体方法**

>例如， Person 类还保存着姓名和一个返回姓名的具体方法。
```java
public abstract class person
{
    private String name;
    public Person(String name)
    {
        this.name = name;
    }
    public abstract String getDescription();
    public String getName()
    {
        return name;
    }
}
```
>**提示**：建议尽量将通用的域和方法（不管是否抽象）放在超类中（不管是否抽象）。

（4）**抽象方法充当着占位的角色，他们的具体实现在子类中**

**1、扩展抽象类可以有两种选择**：
* 在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类。
* 定义全部的抽象方法，这样子类就不是抽象的了。

**2、类就是不含抽象方法，也可以将类声明为抽象类**

**3、抽象类不能被实例化**

如果将一个类声明为abstract，就不能创建这个类的对象：
```java
New Person("TEST")//错误
```
>可以创建一个具体子类的对象

>可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象，例如：
```java
Person p = new Student("Vince Vu","Economic");
```


#### 5.1.10 受保护访问

* 最好将类中的域标记为private，方法标记为public

* 如果希望超类中的某些方法允许被子类访问，或者允许子类的方法访问超类的某个域，可以将这些方法或域声明为**protected**。

>例如，如果将超类Employee中的hireDay 声明为proteced，Manager 中的方法就可以直接地访问它。
不过， Manager 类中的方法只能够访问Manager 对象中的hireDay 域， 而不能访问其他Employee 对象中的这个域。

**1、谨慎使用protected 属性**

>假设需要将设计的类提供给其他程序员使用， 而在这个类中设置了一些受保护域

>由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。在这种情况下， 如果需要对这个类的实现进行修改， 就必须通知所有使用这个类的程序员。这违背了OOP 提倡的数据封装原则。

**2、受保护的方法更具有实际意义**
* 如果需要限制某个方法的使用， 就可以将它声明为protected。
* 这表明子类（可能很熟悉祖先类）得到信任， 可以正确地使用这个方法， 而其他类则不行。

>这种方法的一个最好的示例就是Object 类中的clone 方法， 有关它的详细内容请参看第6 章。

**3、归纳Java中控制可见性的4个访问修饰符**
* private
  * 仅对本类可见
* public
  * 对所有类可见
* protected
  * 对本包和所有子类可见
* 默认，不需要修饰符
  * 对本包可见

### 5.2 Object：所有类的超类

* **Object 类是Java 中所有类的始祖**，在Java中每个类都是由它扩展而来的，如果没有明确地指出超类，Object就是这个类的超类

1、可以使用Object类型的变量引用任何类型的变量：
```java
Object obj = new Employee("Harry Hacker",35000);
```
* Object类型的变量只能用于作为各种值的通用持有者，要想对其中的内容进行具体操作，还要清楚对象的原始类型，并进行类型转换：
```java
Employee e = (Employee) obj;
```
2、在Java中，只有基本类型（primitive types）不是对象

>例如，数值、字符和布尔类型的值都不是对象。
所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。

```java
Employee[] staff = new Employee[10];
obj = staff;//OK
obj = new int[10];//OK
```
#### 5.2.1 equals方法
>Object类中的equals方法用于检测一个对象是否等于另外一个对象。这个方法用于判断**两个对象是否具有相同的引用**。

* 如果两个对象具有相同的引用，那它们一定是相等的

如下示例演示equals方法的实现机制：
```java
public class Employee
{
    public boolean equals(Object otherObject)
    {
        //a quick test to see if the objects are identical
        if(this == otherObject) return true;
        //must return false if the explicit parameter is null
        if(otherObject == null) return false;
        //if the classes don't match, they can't be equal
        if(getClass() != otherObject.getClass()) return false;
        
        //now we know otherObject is a non-null Employee
        Employee other = (Employee)otherObject;
        
        //test whether the fields have identical values
         return name.equals(other.name)
                 && salary == other.salary
                 && hireDay.equals(other.hireDay);
    }
}

```
>getClass方法返回一个对象所属的类。只有两个对象属于同一个类时，才会相等。

>提示：为了防备name或hireDay 可能为null 的情况， 需要使用Objects.equals 方法。
>如果两个参数都为null, Objects.equals(a, b) 调用将返回true ; 
>如果其中一个参数为null,则返回false; 
>否则， 如果两个参数都不为null, 则调用a.equals(b)。
利用这个方法，Employee.equals 方法的最后一条语句要改写为：
```java
return Objects.equals(name, other.name)
&& salary== other.salary
&& Object.equals(hireDay, other.hireDay);
```

在子类中定义equals 方法时， 首先调用超类的equals。如果检测失败， 对象就不可能相等。如果超类中的域都相等， 就需要比较子类中的实例域。

```java
public class Manager extends Employee
{
    public boolean equals(Object otherObject)
    {
        if(!super.equals(otherObject)) return false;
        //super.equals checked that this and otherObject belong to the same class
        Manager other = (Manager)otherObject;
        return bonus == other.bonus;
    }
}
```
#### 5.2.2 相等测试与继承

Java语言规范要求equals方法具有以下特性：
* **自反性**：对于任何非空引用x，x.equals(x)应该返回true；
* **对称性**：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true；
* **传递性**：对于任何引用x、y、和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true；
* **一致性**：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果；
* 对于任意非空引用x，x.equals(null)返回false。

**如果隐式和显示的参数不属于同一个类，equals方法将如何处理？**

**1、不推荐使用instanceof方法进行检测**：

**不符合对称性原则**
```java
if(!(otherObject instanceof Employee)) return false;
```
这样不仅没有解决otherObject是子类的情况，并且还有可能会招惹一些麻烦，例如：

>就**对称性**而言，当参数不属于同一个类时，需要仔细思考:

>e是Employee对象，m是一个Manager对象，并且这两个类具有相同的姓名、薪水和雇用日期。

>如果在Employee.equals中用instanceof 进行检测， 则返回true；然而这意味着反过来调用m.equals(e)  也需要返回true。对称性不允许这个方法调用返回false或抛出异常。

>这就使得Manager 类受到了束缚。这个类的equals 方法必须能够用自己与任何一个Employee 对象进行比较， 而不考虑经理拥有的那部分特有信息。因此instanceof 测试并不是完美无瑕。

**2、有些人认为不应该使用getClass检测**

**因为这不符合置换原则**

>有一个应用AbstractSet 类的equals 方法的典型例子， 它将检测两个集合是否有相同的元素。

>AbstractSet类有两个具体子类： TreeSet 和HashSet, 它们分别使用不同的算法实现查找集合元素的操作。

>无论集合采用何种方式实现， 都需要拥有对任意两个集合进行比较的功能，此时**如果使用getClass()方法，得到的超类都是一样的，然而其对应子类是不一致的**。

然而， 集合是相当特殊的一个例子， 应该将`AbstractSet.equals`声明为final , 这是因为没有任何一个子类需要重定义集合是否相等的语义。不需要继承AbstractSet类

>（事实上， 这个方法并没有被声明为final。这样做， 可以让子类选择更加有效的算法对集合进行是否相等的检测）

**3、下面可以从两个截然不同的情况看一下这个问题**：

* 如果子类能够拥有自己的相等概念， 则对称性需求将强制采用getClass 进行检测
* 如果由超类决定相等的概念，那么就可以使用instanceof 进行检测， 这样可以在不同子类的对象之间进行相等的比较。

1、在雇员和经理的例子中， 只要对应的域相等， 就认为两个对象相等。

>如果两个Manager对象所对应的姓名、薪水和雇佣日期均相等， 而奖金不相等， 就认为它们是不相同的， 因此， 可以使用getClass 检测。

>但是， 假设使用雇员的ID 作为相等的检测标准， 并且这个相等的概念适用于所有的子类， 就可以使用instanceof 进行检测， 并应该将Employee.equals 声明为final。

>**注释**：在标准Java 库中包含150 多个equals 方法的实现， 包括使用instanceof 检测、调用getClass 检测、捕获ClassCastException 或者什么也不做。

>可以查看java.sql.Timestamp 类的API 文档， 在这里实现人员不无尴尬地指出， 他们使自己陷入了困境。Timestamp 类继承自java.util.Date， 而后者的equals 方法使用了一个instanceof 测试， 这样一来就无法覆盖实现equals 使之同时做到对称且正确。

**下面给出一个编写完美equals方法的建议**：
（1）显式参数命名为otherObject，稍后需要将它转换成另一个叫other的变量
（2）检测this与otherObject是否引用同一个对象：
```java
if(this==otherObject) return true;
```
>这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。

（3）检测otherObject是否为null，如果为null，返回false
```java
if(otherObject = null) return false;
```
（4）比较this与otherObject是否属于同一个类。
* 如果equals的语义在每个子类中有所改变，就使用getClass检测：
```java
if(getClass() != otherObject.getCIass()) return false;
```
* 如果所有的子类都拥有统一的语义，就使用instanceof 检测：
```java
if(!(otherObject instanceof ClassName)) return false;
```
（5） 将otherObject 转换为相应的类类型变量：
```java
ClassName other = (ClassName)otherObject;
```
（6）现在开始对所有需要比较的域进行比较了。
* 使用`==`比较基本类型域，使用equals 比较对象域。如果所有的域都匹配， 就返回true; 否则返回false。
```java
return field1==other.field1 && Objects.equals(field2,other.field2);
```
>如果在子类中重新定义equals，就要在其中包含super.equals(other);

>注意：对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。
```java
API java.util.Arrays 1.2
    static Boolean equals(type[] a, type[] b) 5.0
	    如果两个数组长度相同，并且在对应的位置上数据元素也均相同，将返回true。数组的元素类型可以是Object、int、long、short、char、byte、boolean、float 或double。
API java.util.Objects 7
    static boolean equals(Object a, Object b)
	    如果a和b都为null，返回true; 如果只有其中之一为null，则返回false; 否则返回a.equals(b)。
```

#### 5.2.3 hashCode方法
**散列码（hash code）**：是由对象导出的一个整型值。散列码是没有规律的。

>如果x 和y 是两个不同的对象， x.hashCode() 与y.hashCode() 基本上不会相同。

1、String类使用下列算法计算散列码：
```java
int hash = 0;
for(int i=0;i < length(); i++)
{
    hash = 31*hash+charAt(i);
}
```
2、由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。
```java
String s = "OK";
StringBuilder sb = new StringBuilder(s);
System.out.println(s.hashCode() + " " + sb.hashCode());
String t = new String("OK");
StringBuilder tb = new StringBuilder(t);
System.out.println(t.hashCode() + " " + tb.hashCode());
```

结果如下：
![](/001-Java核心技术_卷一/Pictures/5001.jpeg)

>字符串s 与t 拥有相同的散列码， 这是因为字符串的散列码是由内容导出的。

>而字符串缓冲sb 与tb 却有着不同的散列码， 这是因为在StringBuffer 类中没有定义hashCode 方法，它的散列码是由Object 类的默认hashCode 方法导出的对象存储地址。

**如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中**

3、hashCode方法应该返回一个整型数值（也可以是负数），并合理地组合实例域的散列码，以便能让各个不同的对象产生的散列码更加均匀。

>例如，下面是Employee类的hashCode方法
```java
public class Employee()
{
    public int hashCode()
    {
        return 7*name.hashCode()+11*new double(salary).hashCode()+13*hireDay.hashCode();
    }
}
```
>进一步优化，使用null安全的方法`Objects.hashCode`。如果其参数为null，这个方法会返回0。另外使用静态方法`Double.hashCode`来避免创建Double对象：
```java
public int hashCode()
{
    return 7*Objects.hashCode(name)+11*Double.hashCode(salary)+13*Objects.hashCode(hireDay);
}
```
>再进一步优化，需要组合多个散列值时，可以调用Objects.hash 并提供多个参数。这个方法会对各个参数调Objects.hashCode， 并组合这些散列值。
```java
public int hashCode()
{
    return Objects.hash(name,salary,hireDay);
}
```
**Equals 与hashCode 的定义必须一致**
* 如果x.equals(y) 返回true,那么`x.hashCode()`就必须与`y.hashCode()`具有相同的值。

>如果存在数组类型的域，那么可以使用静态的Arrays.hashCode 方法计算一个散列码，这个散列码由数组元素的散列码组成。

```java
API java.util.Object 1.0
	int hashCode()
		返回对象的散列码。散列码可以是任意的整数，包括正数或负数。两个相等的对象要求返回相等的散列码。
API java.util.Objects 7
	static int hash(Object . . . objects)
		返回一个散列码，由提供的所有对象的散列码组合而得到。
	static int hashCode(Object a)
		○ 如果a为null返回0，否则返回a.hashCode()。
API java.lang.(lnteger|Long|Short|Byte|Double|Float|Character|Boolean) 1.0
	static int hashCode((int|long|short|byte|double|float|char|boolean) value) 8
		返回给定值的散列码。
API java.util.Arrays 1.2
	static int hashCode(type[] a) 5.0
		○ 计算数组a的散列码。组成这个数组的元素类型可以是object，int，long，short，char，byte，boolean，float或double。
```

#### 5.2.4 toString方法

* 在Object中还有一个重要的方法，toString方法。toString方法用于返回表示对象值的字符串。

>Point类的toString方法将返回下面这样的字符串：
```java
java.awt.Point[x=10，y=20]
```
**toString方法的格式**
* 绝大多数（但不是全部）的toString 方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。

>如下，是Employee类的toString方法的实现：
```java
public String toString()
{
    return "Employee[name="+name
        +",slalry="+salary
        +",hireDay="+hireDay
        +"]";
}
```
>进一步优化，通过调用getClass().getName()获得类名的字符串，不要将类名硬加到toString方法中。
```java
public String toString()
{
    return getClass().getName()
        +"[name="+name
        +",slalry="+salary
        +",hireDay="+hireDay
        +"]";
}
```
>如果超类使用了getClass().getName(), 那么子类只要调用super.toString() 就可以了。例如，
```java
public class Manager extends Employee
{
    public String toString()
    {
        return super.toString()
            +"[bonus="+bonus
            +"]";
    }
}
```

**随处可见toString 方法的主要原因是：**
* 只要对象与一个字符串通过操作符“ +” 连接起来，Java 编译就会自动地调用toString 方法，以便获得这个对象的字符串描述。
```java
Point p = new Point(10,20);
String message = "The current position is "+p;
//automatically invokes p.toString()
```
>提示：在调用x.toString( ) 的地方可以用`""+x`替代。这条语句将一个空串与x 的字符串表示相连接。这里的x 就是x.toString( )。 与toString 不同的是， 如果x 是基本类型， 这条语句照样能够执行。

* 如果x 是任意一个对象， 并调用`System.out.println(x)`；println 方法就会直接地调用x.toString()，井打印输出得到的字符串。
* Object 类定义了toString 方法， 用来打印输出**对象所属的类名和散列码**。

>例如， 调用`System.out.println(System.out)`，将输出：`java.io.PrintStream@6bc7c054`
之所以得到这样的结果是因为PrintStream 类的设计者没有覆盖toString 方法。

**警告**：数组继承了object 类的toString 方法， 数组类型将按照旧的格式打印。
>例如：如下生成字符串，[I@6bc7c054，I表示整型数组
int[] luckyNumbers = {2,3,5,7,11,13};
String s = "" + luckyNumbers;

**修正**：调用静态方法`Array.toString()`，将生成字符串[2, 3, 5, 7, 11, 13]
要想打印多维数组（即，数组的数组）则需要调用`Arrays.deepToString`方法。

**toString 方法是一种非常有用的调试工具**
>在标准类库中，许多类都定义了toString 方法， 以便用户能够获得一些有关对象状态的必要信息。像下面这样显示调试信息非常有益：
```java
System,out.println("Current position = " + position);
```
读者在第7 章中将可以看到，更好的解决方法是：
```java
Logger.global.info("Current position = " + position);
```

>提示： 强烈建议为自定义的每一个类增加toString 方法。这样做不仅自己受益， 而且所有使用这个类的程序员也会从这个日志记录支持中受益匪浅。

```java
API java.lang.Object 1.0
    Class getClass()
        返回包含对象信息的类对象。稍后会看到Java 提供了类运行时的描述，它的内容被封装在Class 类中。
    boolean equals(Object otherObject)
        比较两个对象是否相等， 如果两个对象指向同一块存储区域，方法返回true ; 否则方法返回false。在自定义的类中， 应该覆盖这个方法.
    String toString()
        返冋描述该对象值的字符串。在自定义的类中， 应该覆盖这个方法。
API java.lang.Class 1.0
    String getName()
        返回这个类的名字。
    Class getSuperclass()
        以Class对象的形式返回这个类的超类信息。
```

### 5.3 泛型数组列表

**问题**：如何运行时动态更改数组？

**1、Java允许在运行时确定数组的大小**
```java
int actualSize = ...;
Employee[] staff = new Employee[actualSize];
```
>上述代码并没有完全解决运行时动态更改数组的问题，一旦确定了数组的大小，就不容易更改。

**2、在Java中，解决问题最简单的方式是使用ArrayList类**

>使用起来像数组，但在添加或删除元素时，具有自动调节数组容量的功能。

**ArrayList是一个采用类型参数（type parameter）的泛型类（generic class）**。

* 为了指定**数组列表保存的元素对象类型**，需要用一对尖括号将类名括起来加在后面。（在第8章会看到如何定义一个泛型类，例如：`ArrayList<Employee>`）

下面声明和构造一个保存Employee对象的数组列表：
```java
ArrayList<Employee> staff = new ArrayList<Employee>();
```
在Java SE 7中，可以省去右边的类型参数：
```java
ArrayList<Employee> staff = new ArrayList<>();
```
**菱形语法**
>因为空尖括号<>就像是一个菱形。

* 可以结合new 操作符使用菱形语法。编译器会检查新值是什么。
* 如果赋值给一个变量、或传递到某个方法、或者从某个方法返回，    编译器会检査这个变量、参数或方法的泛型类型， 然后将这个类型放在<>中。
* 在这个例子中，new ArrayList<>() 将赋至一个类型为ArrayList<Employee> 的变量， 所以泛型类型为Employee。

>**注释**：Java SE 5.0 以前的版本没有提供泛型类， 而是有一个ArrayList 类， 其中保存类型为Object 的元素， 它是“ 自适应大小” 的集合。
>如果一定要使用老版本的Java, 则需要将所有的后缀<. . .> 删掉, ， 在Java SE 5.0 以后的版本中， 没有后缀<...> 仍然可以使用ArrayList, 它将被认为是一个删去了类型参数的“ 原始” 类型。

**使用add方法可以将元素添加到数组列表中**：
```java
staff.add(new Employee("Harry Hacker",...));
staff.add(new Employee("Tony Tester",...));
```
>**数组列表空间管理**：数组列表管理这对象引用的一个内部数组，数组的全部空间有可能被用尽，如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。

**ensureCapacity方法，指定数组列表大小**

>如果已经清楚或者能估计出数组可能存储的元素数量，可以在填充数组之前调用ensureCapacity方法

>如下方法调用将分配一个包含100个对象的内部数组，，然后调用100次add，而不用重新分配空间
```java
staff.ensureCapacity(100);
```
**还可以把初始容量传递给ArraList构造器**：
```java
ArrayList<Employee> staff = new ArrayList<>(100);
```

**数组列表的容量与数组的大小有一个很重要的区别**：
* 如果为数组分配100个元素存储空间，数组就有100个空位置可以使用。
* 而容量为100个元素的数组列表只是拥有保存100个元素的潜力（实际上，重新分配空间，将会超过100），但是在最初，甚至完成初始化构造之后，数组列表根本就不含有任何元素。

**后续是如何扩展的，每次新增多少空间？？？**

**size方法将返回数组列表中包含的实际元素数目**
```java
staff.size()
```
>相当于数组a的a.lengh

**trimToSize回收多余空间**
>一旦确定数组列表的大小不会再发生变化，就可以调用trimToSize方法。

* 这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目，垃圾回收器将回收多余的存储空间。

```java
API java.util.ArrayList<E> 1.2
    Array List<E>()
        构造一个空数组列表。
    ArrayList<E> (int initialCapacity)
        用指定容量构造一个空数组列表。
            参数：initalCapacity   数组列表的最初容量
    boolean add(E obj)
        在数组列表的尾端添加一个元素。永远返回true。
            参数：obj   添加的元素
    int size()
        返回存储在数组列表中的当前元素数量。（这个值将小于或等于数组列表的容量。)
    void ensureCapacity(int capacity)
        确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。
            参数：capacity  需要的存储容量
    void trimToSize()
        将数组列表的存储容量削减到当前尺寸。
```


#### 5.3.1 访问数组列表元素

>数组列表自动扩展容量的便利增加了访问元素语法的复杂程度
>因为ArrayList类并不是Java程序设计语言的一部分，只是一个由某些人编写并放在标准库中的一个实用类

**1、使用get和set方法实现访问或改变数组元素**

* 使用set方法替换数组中已经存在的元素内容（不能为数组添加新元素）。
```java
//例如，设置第i个元素：
staff.set(I, harry);
```
>等价于对数组a的元素赋值（数组的下标从0开始）：
a[i] = harry;

* 使用get方法获得数组列表的元素：
```java
Employee e = staff.get(i);
```
>等价于
Employee e = a[i];

>**注释**：没有泛型类时，原始的ArrayList类提供的get方法只能返回Object，因此get方法的调用者必须对返回值进行类型转换：
Employee e = (Employee)staff.get(i);

>原始的ArrayList 存在一定的危险性。它的add 和set 方法允许接受任意类型的对象。
对于下面这个调用  
staff.set(i , "Harry Hacker")
编译不会给出任何警告， 只有在检索对象并试图对它进行类型转换时， 才会发现有问题。如果使用ArrayList<Employee>, 编译器就会检测到这个错误。

**2、 可以灵活地扩展数组，又可以方便地访问数组元素**
```java
//首先，创建一个数组， 并添加所有的元素。
ArrayList<X> list = new ArrayListoQ;
while (...)
{
    x = . .;
    list.add(x);
}
//执行完上述操作后，使用toArray 方法将数组元素拷贝到一个数组中。
X[] a = new X[list.size()];
list.toArray(a);
```
**3、数组列表的插入和删除操作**
* 可以在数组列表的尾部和在数组列表的中间插入元素，使用带索引参数的add方法
```java
int n = staff.size() / 2;
staff.add(n,e);
```

>为了插入一个新元素，位于n 之后的所有元素都要向后移动一个位置。如果插入新元素后， 数组列表的大小超过了容量，数组列表就会被重新分配存储空间。

* 可以从数组列表中间删除一个元素
```java
Employee e = staff.remove(n);
```
>位于这个位置之后的所有元素都向前移动一个位置，并且数组的大小减1

**对数组实施插人和删除元素的操作其效率比较低**
* 对于小型数组来说， 这一点不必担心。
* 但如果数组存储的元素数比较多， 又经常需要在中间位置插入、删除元素， 就应该**考虑使用链表**了。有关链表操作的实现方式将在第9 章中讲述。


**4、可以使用“foreach” 循环遍历数组列表**
```java
for (Employee e: staff)
    do something with e
```
这个循环和下列代码具有相同的效果
```java
for(int i = 0; i < staff .size(); i++)
{
    Employee e = staff.get(i);
    do something with e
}
```

```java
API java.util.ArrayList<T> 1.2
    void set(int index, E obj)
        设置数组列表指定位置的元素值，这个操作将覆盖这个位置的原有内容。
            参数： index 位置（必须介于0 ~ size()-1 之间），obj 新的值
    E get(int index)
        获得指定位置的元素值。
            参数：index 获得的元素位置（必须介于0 ~ size()-1 之间）
    void add(int index,E obj)
        向后移动元素， 以便插入元素。
            参数： index 插入位置（必须介于0 ~size()-1 之间），obj 新元素
    E removed(int index)
        删除一个元素，并将后面的元素向前移动。被删除的元素由返回值返回。
            参数：index 被删除的元素位置（必须介于0 ~size()-1之间）
```

#### 5.3.2 类型化与原始数组列表的兼容性

在自己的代码中，更希望使用类型参数来增加安全性。

本节会介绍如何与没有使用类型参数的遗留代码交互操作

假设有下面这个遗留下来的类：
```java
public class EmployeeB
{
    public void update(ArrayList list){...}
    public ArrayList find(String query){...}
}
```
可以将一个类型化的参数列表传递给update方法，而不需要进行任何类型转换。
也可以将staff对象传给update方法。
```java
ArrayList<Employee> staff = ...;
EmployeeB.update(staff);
```


>**警告**：尽管编译器没有给出任何错误信息或警告， 但是这样调用并不太安全。在update方法中， 添加到数组列表中的元素可能不是Employee 类型。在对这些元素进行检索时就会出现异常。听起来似乎很吓人，但思考一下就会发现， 这与在Java 中增加泛型之前是一样的，虚拟机的完整性绝对没有受到威胁。在这种情形下， 既没有降低安全性， 也没有受益于编译时的检查。

* 相反，将一个原始ArrayList赋值给一个类型化ArrayList会得到一个警告。
```java
ArrayList<Employee> result = EmployeeB.find(query);//yields warning
```
* 使用类型转换并不能避免出现警告。这样， 将会得到另外一个警告信息， 指出类型转换有误。
```java
ArrayList<Employee> result = (ArrayList<Employee>) employeeDB.find(query);
// yields another warning
```
**这就是Java 中不尽如人意的参数化类型的限制所带来的结果**

>鉴于兼容性的考虑， 编译器在对类型转换进行检査之后， 如果没有发现违反规则的现象， 就将所有的类型化数组列表转换成原始ArrayList 对象。

>在程序运行时， 所有的数组列表都是一样的， 即没有虚拟机中的类型参数。因此， 类型转换`（ ArrayList ) 和( ArrayList<Employee> ) `将执行相同的运行时检查。

>在这种情形下，只要在与遗留的代码进行交叉操作时，研究一下编泽器的警告性提示，并确保这些警告不会造成太严重的后果就行了。

>一旦能确保不会造成严重的后果， 可以用@SuppressWarnings("unchecked") 标注来标记这个变量能够接受类型转换， 如下所示：
```java
@SuppressWarnings("unchecked") ArrayList<Employee> result =
(ArrayList<Employee>) employeeDB.find(query); // yields another warning
```

### 5.4 对象包装器与自动装箱

* **包装器（wrapper)**：基本类型都有一个与之对应的类，这些类称为包装器。

>例如，Integer 类对应基本类型int。

**这些对象包装器类拥有很明显的名字**：Integer、Long、Float、Double、Short、Byte、Character 、Void 和Boolean ( 前6个类派生于公共的超类Number)。

**1、对象包装器类是不可变的**

* 一旦构造了包装器， 就不允许更改包装在其中的值
* 对象包装器类还是final , 因此不能定义它们的子类

>假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型， 也就是说，不允许写成`ArrayList<int>`。这里就用到了Integer 对象包装器类。我们可以声明一个Integer对象的数组列表。
```java
ArrayList<Integer> list = new ArrayList<>();
```
>**警告**： 由于每个值分别包装在对象中， 所以ArrayList<lnteger> 的效率远远低于int[ ] 数组。因此， 应该用它构造小型集合， 其原因是此时程序员操作的方便性要比执行效率更加重要。

**2、自动装箱（autoboxing）**
* 便于添加int 类型的元素到ArrayList<lnteger>中。
```java
//下面这个调用
list.add(3);
//将自动地变换成
list.add(Integer.value0f(3));
```
>这种变换被称为自动装箱（autoboxing)。

**3、自动拆箱**
* 当将一个Integer 对象赋给一个int 值时， 将会自动地拆箱
```java
//编译器将下列语句：
int n = list.get(i);
//翻译成
int n = list.get(i).intValue();
```
* 在算术表达式中也能够自动地装箱和拆箱。

>例如，可以将自增操作符应用于一个包装器引用：编译器将自动地插入一条对象拆箱的指令， 然后进行自增计算， 最后再将结果装箱
```java
Integer n = 3;
n++;
```
* == 运算符也可以应用于对象包装器对象
>检测的是对象是否指向同一个存储区域
```java
//下面的比较通常不会成立
Integer a = 1000;
Integer b = 1000;
if(a==b)...
```
**如果将经常出现的值包装到同一对象中，上述比较有可能出现，为了避免这种情况，在两个包装器对象比较时调用equals 方法**

>**注释**：自动装箱规范要求boolean、byte、char<127， 介于-128 ~ 127 之间的short 和int 被包装到固定的对象中。
例如：如果在前面的例子中将a 和b 初始化为100， 对它们进行比较的结果一定成立。

**4、自动装箱的几点说明**：
* 由于包装器类引用可以为null , 所以自动装箱有可能会抛出一个NullPointerException 异常：
```java
Integer n = null;
System.out.println(2 * n);// Throws NullPointerException
```
* 如果在一个条件表达式中混合使用Integer 和Double 类型， Integer 值就会拆箱，提升为double, 再装箱为Double:
```java
Integer n = 1;
Double x = 2.0;
System.out.println(true ? n : x);// Prints 1.0
```
* 装箱和拆箱是编译器认可的， 而不是虚拟机：
>编译器在生成类的字节码时， 插入必要的方法调用。虚拟机只是执行这些字节码。


**5、使用数值对象包装器还有另外一个好处**：
* Java设计者发现，可以将某些基本方法放置在包装器中，例如，将一个数字字符串转换成数值。
```java
//要想将字符串转换为整型，可以使用下面这一条语句：
int x = Integer.parseInt(s);
```
>这里与Integer对象没有任何关系，parseInt是一个静态方法，但是Integer类是放置这个方法的一个好地方。

>**警告**：包装器类不能用来实现修改数值参数的方法。
由于Java方法都是值传递的，所以不可能编写一个下面这样的能够增加整型参数值的Java方法。
```java
public static void triple(int x)//won't work
{
    x = 3 * x;
}
public static void triple(Integer x)//won't work
{
    ...
}
```
**Integer 对象是不可变的**： 包含在包装器中的内容不会改变，不能使用这些包装器类创建修改数值参数的方法。


>如果想编写一个修改数值参数值的方法， 就需要使用在org.omg.CORBA 包中定义的持有者（ holder ) 类型， 包括IntHolder、BooleanHolder 等。
每个持有者类型都包含一个公有（!）域值， 通过它可以访问存储在其中的值。
```java
public static void triple(IntHolder x)
{
    x.value = 3 * x.value;
}
```

```java
API java.lang.Integer 1.0
    int intValue()
        以int 的形式返回Integer对象的值（在Number 类中覆盖了intValue 方法），相当于把Integer对象转化成int。
    static String toString(int i)
        以一个新String 对象的形式返回给定数值i 的十进制表示。
        String a = Integer.toString(99);
    static String toString(int i ,int radix)
        返回数值i的基于给定radix 参数进制的表示,如果radix是2，表示返回i的二进制。
    static int parseInt(String s)
    static int parseInt(String s,int radix)
        返回字符串s 表示的整型数值， 给定字符串表示的是十进制的整数（第一种方法)，
        或者是radix 参数进制的整数（第二种方法)
```



### 5.5 参数数量可变的方法

* 在Java SE 5.0 以前的版本中， 每个Java方法都有固定数量的参数
* 现在的版本提供了可以用**可变的参数数量**调用的方法（有时称为“ 变参” 方法)。

>例如，printf方法，参数不同，但是调用的是同一个方法：
```java
System.out.printf("%d",n);
System.out.printf("%d %s",n,"widgets");
```

**1、printf方法的定义**
```java
public class PrintStream
{
    public PrintStream printf(String fmt, Object ... args) {return format(fmt, args);}
}
```
* 这里的省略号`...`是Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除fmt参数之外)，**可变参数**。

**printf 方法接收两个参数**
* 一个是格式字符串
* 另一个是Object[] 数组， 其中保存着所有的参数（如果调用者提供的是整型数组或者其他基本类型的值， 自动装箱功能将把它们转换成对象)。

* 对于printf 的实现者来说，Object… 参数类型与Object[] 完全一样。

编译器需要对printf 的每次调用进行转换， 以便将参数绑定到数组上， 并在必要的时候进行自动装箱：
```java
System.out.printf("%d %s", new Object[]{new Integer(n), "widgets"});
```
**2、用户可以定义可变参数的方法，并将参数指定为任意类型，甚至是基本类型**

>示例：其功能为计算若干个数值的最大值
```java
public static double max(double... values)
{
    double largest = Double.NEGATIVE_INFINITY;
    for(double v: values)
    {
        if(v > largest)
            largest = v;
    }
    return largest;
}
```
可以像下面这样调用这个方法：
```java
double m = max(3.1, 40.4, -5);
```
编译器将new double[] {3.1, 40.4,-5} 传递给max 方法，即：
```java
double m = max(new double[]{3.1, 40.4, -5});
```

>**注释**：允许将一个数组传递给可变参数方法的最后一个参数。例如：
```java
System.out.printf("%d %s", new Object[]{new Integer(l), "widgets"});
```
>因此， 可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。

>例如， MessageFormat.format 在Java SE 5.0 就采用了这种方式。甚至可以将main 方法声明为下列形式：
```java
public static void main(String... args)
```

### 5.6 枚举类

* 如何定义枚举类型，如下所示：
```java
public enum Szie{SMALL,MEDIUM,LARGE,EXTRA_LARGE};
```

* 实际上，这个**声明定义的类型是一个类**，它刚好有4个实例，在此尽量不要构造新对象。

* 因此， 在比较两个枚举类型的值时， 永远不需要调用equals, 而直接使用“ ==” 就可以了。


>如果需要的话， 可以在枚举类型中添加一些构造器、方法和域。当然， 构造器只是在构造枚举常量的时候被调用。下面是一个示例：
```java
public enum Size
{
    SMALL("S"), MEDIUM("M") , LARGE("L") , EXTRA_LARGE("XL");
    private String abbreviation;
    
    private Size(String abbreviation){this.abbreviation = abbreviation;}
    public String getAbbreviation() {
        return abbreviation;
    }
}
```

**所有的枚举类型都是Enum 类的子类。它们继承了这个类的许多方法。**
**1、toString**
>这个方法能够返回枚举常量名
例如， Size.SMALL.toString( ) 将返回字符串“SMALL”。

* toString 的逆方法是静态方法valueOf
```java
例如， 如下语句，将s设置成Size.SMALL
Size s = Enum.valueOf(Size.class,"SMALL");
```
**2、values方法**
>每个枚举类型都有一个静态的values 方法， 它将返回一个包含全部枚举值的数组
```java
//返回包含元素Size.SMALL,SIZE.MEDIUM,Size.LARG和Size.EXTRA_LARGE 的数组。
Size[] values = Size.values();

```
**3、ordinal方法**
>ordinal 方法返冋enum 声明中枚举常量的位置， 位置从0 开始计数。
```java
//返回1
Size.MEDIUM.ordinal(); 
```

>**注释**： 如同Class 类一样， 鉴于简化的考虑，Enum 类省略了一个类型参数。例如， 实际上， 应该将枚举类型Size扩展为`Enum<Size>`。
类型参数在compareTo方法中使用（comPareTo 方法在第6 章中介绍， 类型参数在第8 章中介绍）。
**不是很理解**

```java
API java.Iang.Enum <E> 5.0
    static Enum valueOf (Class enumClass, String name)
        返回指定名字、给定类的枚举常量。
    String toString()
        返回枚举常量名。
    int ordinal()
        返回枚举常量在enum 声明中的位置，位置从0 开始计数。
    int compareTo(E other)
        如果枚举常量出现在Other之前， 则返回一个负值；如果this=other，则返回0; 否则，返回正值。枚举常量的出现次序在enum 声明中给出。用于比较两个枚举常量的位置
        int t = size.compareTo(Size.MEDIUM);
```
### 5.7 反射

>反射库（reflection library）提供了一个非常丰富且精心设计的工具集，以便编写能动态操作Java代码的程序。

>这项功能被大量地应用于JavaBeans中，它是Java组件的体系结构。

>使用反射，Java在设计或运行中添加新类时，**能够快速地应用开发工具动态地查询新添加类的能力**

**反射（reflective）**：能够分析类能力的程序。反射的功能及其强大，用途如下：
* 在运行时分析类的能力
* 在运行时查看对象， 例如， 编写一个toString 方法供所有类使用
* 实现通用的数组操作代码
* 利用Method 对象， 这个对象很像C++中的函数指针。

>反射是一种功能强大且复杂的机制。使用它的主要人员是工具构造者， 而不是应用程序员

#### 5.7.1 Class类
>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为**运行时**的类型标识。

>这个信息跟踪着每个对象所属的类，虚拟机利用运行时类型信息选择相应的方法执行。

**可以通过专门的Java类访问这些信息，保存这些信息的类被称为Class**

**1、获取class类的方式**
**（1）Object类中的getClass()方法将会返回一个Class 类型的实例**
```java
Employee e;
...
Class cl = e.getClass();
```
* 一个Class对象将表示一个特定类的属性



如果类在一个包里，包的名字也作为类名的一部分：
```java
Random generator = new Random();
Class cl = generator.getClass();
String name = cl.getName();// name is set to "java.util.Random"
```

**（2）调用静态方法forName 获得类名对应的Class 对象**

```java
String className = "java.util.Random";
Class cl = Class.forName(className);
```
* 如果类名保存在字符串中， 并可在运行中改变， 就可以使用这个方法
* 这个方法只有在className 是类名或接口名时才能够执行。否则， forName 方法将抛出一个checkedexception ( 已检查异常）。
* 无论何时使用这个方法， 都应该提供一个异常处理器（ exceptionhandler ) 。 如何提供一个异常处理器， 请参看下一节。

>提示：在启动时， 包含main 方法的类被加载。它会加载所有需要的类。这些被加载的类又要加载它们需要的类，以此类推。对于一个大型的应用程序来说， 这将会消耗很多时间， 用户会因此感到不耐烦。可以使用下面这个技巧给用户一种启动速度比较快的幻觉。

>不过，要确保包含main方法的类没有显式地引用其他的类。

>首先，显示一个启动画面；然后， 通过调用Class.forName 手工地加载其他的类。

**（3）如果T是任意的Java类型（或void关键字），T.class将代表匹配的类对象**
```java
Class cll = Random.class;//if you import java.util
Gass cl2 = int.class;
Class cl3 = Double[].class;
```
**2、一个Class 对象实际上表示的是一个类型， 而这个类型未必一定是一种类**
>例如，int 不是类， 但int.class 是一个Class 类型的对象。

>注释：Class 类实际上是一个泛型类。例如， Employee.class 的类型是`Class<Employee>`。

>没有说明这个问题的原因是：它将已经抽象的概念更加复杂化了。在大多数实际问题中， 可以忽略类型参数，而使用原始的Class 类。有关这个问题更详细的论述请参看第8 章

>**警告**：鉴于历史原因，getName 方法在应用于数组类型的时候会返回一个很奇怪的名字：
```java
Double[].class.getName() 返回 "[Ljava.lang.Double;"
int[].class.getName() 返回 "[I"
```

**3、虚拟机为每个类型管理一个Class 对象。因此， 可以利用==运算符实现两个类对象比较的操作**
```java
if(e.getClass() == Employee.class). . .
```

**4、Class对象方法**

* **getName()方法**，这个方法将返回类的名字，如下：
```java
//如果e是一个雇员，会输出：Employee Harry Hacker
//如果e是一个经理，会输出：Manager Harry Hacker
System.out.println(e.getClass().getname()+" "+e.getName());
```

* **newlnstance()**，可以用来动态地创建一个类的实例
```java
e.getClass().newlnstance();
```

>创建了一个与e 具有相同类类型的实例。newlnstance 方法调用默认的构造器（没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。

>将forName 与newlnstance 配合起来使用， 可以根据存储在字符串中的类名创建一个对象：
```java
String s = "java.util .Random";
Object m = Class.forName(s).newInstance();
```
>注释： 如果需要以这种方式向希望按名称创建的**类的构造器提供参数**，就不要使用上面那条语句， 而必须使用Constructor 类中的newlnstance 方法。



#### 5.7.2 捕获异常
我们将在第7 章中全面地讲述异常处理机制，但现在时常遇到一些方法需要抛出异常。

>当程序运行过程中发生错误时，就会“抛出异常”。抛出异常比终止程序要灵活得多，这是因为可以提供一个“捕获” 异常的处理器（handler ) 对异常情况进行处理。

>如果没有提供处理器， 程序就会终止，并在控制台上打印出一条信息，其中给出了异常的类型。例如， 偶然使用了null 引用或者数组越界等。

**异常有两种类型：未检查异常**和**已检查异常**
* 对于已检查异常， 编译器将会检查是否提供了处理器
* 然而有很多常见的异常都属于未检查异常，例如，访问null 引用。编译器不会查看是否为这些错误提供了处理器。(毕竟，应该精心地编写代码来避免这些错误的发生， 而不要将精力花在编写异常处理器上。)

>并不是所有的错误都是可以避免的。如果竭尽全力还是发生了异常， 编译器就要求提供一个处理器。

Class.forName 方法就是一个抛出已检查异常的例子。现在介绍一下如何实现最简单的处理器。
```java
try
{
    statements that might throw exceptions
}
catch (Exception e)
{
    handler action
}
```
下面是一个示例：
```java
try
{
    String name = . . .; // get class name
    Class cl = Class.forName(name);// might throw exception
    dosomething with cl
}
catch (Exception e)
{
    e.printStackTrace();
}
```

>如果类名不存在， 则将跳过try 块中的剩余代码， 程序直接进入catch 子句（这里，利用Throwable 类的printStackTrace 方法打印出栈的轨迹。Throwable 是Exception 类的超类）。

>如果try 块中没有抛出任何异常， 那么会跳过catch 子句的处理器代码。

* 对于已检查异常， 只需要提供一个异常处理器。可以很容易地发现会抛出已检査异常的方法
* 如果调用了一个抛出已检查异常的方法， 而又没有提供处理器， 编译器就会给出错误报告。

```java
API java.lang.Class 1.0
    static Class forName(String className)
        返回描述类名为className的Class对象。
    Object newInstance()
        返回这个类的一个新实例。

API java.lang.reflect.Constructor 1.1
    Object newInstance(Object[] args)
        构造一个这个构造器所属类的新实例。
        参数：args 这是提供给构造器的参数。有关如何提供参数的详细情况请参看5.7.6节的论述。

API java.lang.Throwable 1.0
    void printStackTrace()
        将Throwable对象和栈的轨迹输出到标准错误流。
```
#### 5.7.3 利用反射分析类的能力

下面简要介绍一下反射机制最重要的内容--**检查类的结构**

* java.lang.reflect 包中有三个类
    * Field-类的域
    * Method-类的方法
    * Constructor-类的构造器。

**1、getName方法**

>三个类都有，用来返回项目的名称。

**2、getType方法**

>Field类有，用来返回描述域所属类型的Class对象。

**3、报告类型参数方法**
>Method 和Constructor 类有能够报告参数类型的方法， Method 类还有一个可以报告返回类型的方法。

**4、getModifiers**

>三个类都有，将返回一个整型数值，用不同的位开关描述public和static这样的修饰符使用状况。

**5、Modifier类的静态方法**

>还可以利用java.lang.reflect 包中的Modifier类的静态方法分析getModifiers 返回的整型数值。

>例如， 可以使用Modifier 类中的isPublic、isPrivate 或isFinal判断方法或构造器是否是public、private 或final。

>我们需要做的全部工作就是调用Modifier类的相应方法， 并对返回的整型数值进行分析， 另外， 还可以利用Modifier.toString 方法将修饰符打印出来。

**5、Class 类中的getFields、getMethods 和getConstructors方法**

* getFields - 返回类提供的public 域
* getMethods - 返回类提供的public 方法
* getConstructors - 返回类提供的public 构造器数组

>其中包括超类的公有成员。

**6、Class 类的getDeclareFields、getDeclareMethods 和getDeclaredConstructors 方法**
* getDeclareFields - 返回类中声明的全部域
* getDeclareMethods - 返回类中声明的全部方法
* getDeclaredConstructors - 返回类中声明的全部构
造器

>其中包括私有和受保护成员，但不包括超类的成员。

```java
API java.lang.Class 1.0
    Field[] getFields() 1.1
    Filed[] getDeclaredFilds() 1.1
        getFields 方法将返回一个包含Field 对象的数组， 这些对象记录了这个类或其超类的公有域。
        getDeclaredField 方法也将返回包含Field 对象的数组， 这些对象记录了这个类的全部域。如果类中没有域，或者Class对象描述的是基本类型或数组类型， 这些方法将返回一个长度为0 的数组。
    Method[] getMethods() 1.1
    Method[] getDeclareMethods() 1.1
        返回包含Method 对象的数组：getMethods将返回所有的公有方法，包括从超类继承来的公有方法;
        getDeclaredMethods 返回这个类或接口的全部方法， 但不包括由超类继承了的方法。
    Constructor[] getConstructors() 1.1
    Constructor[] getDeclaredConstructors() 1.1
        返回包含Constructor 对象的数组， 其中包含了Class 对象所描述的类的所有公有构造器（getConstructors ) 或所有构造器（getDeclaredConstructors)

API java.lang.reflect.Field 1.1
API java.lang.reflect.Method 1.1
API java.lang.reflect.Constructor 1.1
    Class getDeclaringClass()
        返冋一个用于描述类中定义的构造器、方法或域的Class 对象。
    Class[] getExceptionTypes() (在Constructor 和Method 类中）
        返回一个用于描述方法抛出的异常类型的Class 对象数组。
    int getModifiers()
	    返回一个用于描述构造器、方法或域的修饰符的整型数值。使用Modifier类中的这个方法可以分析这个返回值。
    String getName()
        返冋一个用于描述构造器、方法或域名的字符串。
    Class[] getParameterTypes() (在Constructor和Method 类中）
        返回一个用于描述参数类型的Class 对象数组。
    Class getReturnType() (在Method 类中）
        返回一个用于描述返回类型的Class对象。

API java.lang.reflect.Modifier 1.1
    static String toString(int modifiers)
        返回对应modifiers 中位设置的修饰符的字符串表示。
    static boolean isAbstract(int modifiers)
    static boolean isFinal(int modifiers)
    static boolean isInterface(int modifiers)
    static boolean isNative(int modifiers)
    static boolean isPrivate(int modifiers)
    static boolean isProtected(int modifiers)
    static boolean isPublic(int modifiers)
    static boolean isStatic(int modifiers)
    static boolean isStrict(int modifiers)
    static boolean isSynchronized(int modifiers)
    static boolean isVolatile(int modifiers)
        这些方法将检测方法名中对应的修饰符在modifiers值中的位。
```

#### 5.7.4 在运行时使用反射分析对象

* 如何查看任意对象的数据域名称和类型：
    * 获得对应的Class 对象。
    * 通过Class 对象调用getDeclaredFields。

**利用反射机制可以查看在编译时还不清楚的对象域**

**1、使用Field类中的get方法查看对象域**

>如果f是一个Field类型的对象（例如，通过getDeclaredFields得到的对象），obj是某个包含f域的类的对象，f.get(obj) 将返回一个对象，其值为obj 域的当前值。

>这样说起来显得有点抽象，这里看一看下面这个示例的运行：

```java
Employee harry = new Employee("Harry Hacker",35000,10,1,1989);
//the class object representing Employee
Class cl = harry.getClass();
//the name field of the Employee class
Field f = cl.getDeclaredField("name");
//the value of the name field of the harry object, i.e.(即), the String object "Harry Hacker"
Object v = f.get (harry);
```

**上述代码存在的问题**：
>由于name 是一个私有域，所以get方法将会抛出一个IllegalAccessException。

>只有利用get方法才能得到可访问域的值。除非拥有访问权限，否则Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。

**2、反射机制的默认行为受限于Java 的访问控制**

>但是，如果一个Java 程序没有受到安全管理器的控制，就可以覆盖访问控制。

>为了达到这个目的， 需要调用Field、Method 或Constructor 对象的setAccessible 方法。例如，
```java
f.setAtcessible(true);//now OK to call f.get(harry);
```
**setAccessible 方法**
1. setAccessible 方法是AccessibleObject 类中的一个方法，它是Field、Method 和Constructor类的公共超类。
2. 这个特性是为调试、持久存储和相似机制提供的。


**3、get方法返回值类型问题**

>name 域是一个String，因此把它作为Object 返回没有什么问题。但是， 假定我们想要查看salary 域。它属于double 类型， 而Java 中数值类型不是对象。

要想解决这个问题， 可以使用Field 类中的getDouble 方法， 也可以调用get方法， 此时， 反射机制将会自动地将这个域值打包到相应的对象包装器中， 这里将打包成Double。

当然，可以获得就可以设置。调用f.set(obj, value) 可以将obj 对象的f 域设置成新值。

```java
API java.lang.reflect.AccessibleObject 1.2
    void setAccessible(boolean flag)
        为反射对象设置可访问标志。flag 为true 表明屏蔽Java 语言的访问检查，使得对象的私有属性也可以被査询和设置。
    boolean isAccessible()
        返回反射对象的可访问标志的值。
    static void setAccessible(AccessibleObject[] array,boolean flag)
        是一种设置对象数组可访问标志的快捷方法。

API java.lang.Class 1.1
    Field getField(String name)
    Field[] getField()
        返回指定名称的公有域，或包含所有域的数组
    Field getDeclaredField(String name)
    Field[] getDeclaredFields()
	    返回类中声明的给定名称的域，或者包含声明的全部域的数组。

API java.lang.reflect.Field 1.1
    Object get(Object obj)
        返回obj 对象中用Field 对象表示的域值。
    void set(Object obj, Object newValue)
        用一个新值设置Obj 对象中Field 对象表示的域。
```

#### 5.7.5 使用反射编写泛型数组代码
* java.lang.reflect包中的Array类允许动态地创建数据。

>例如，将这个特性应用到Array类中的copyOf方法实现中，这个方法可以用于扩展已经填满的数组。
```java
Employee[] a = new Employee[100];
...
//array is full
a = Arrays.copyOf(a, 2 * a.length);
```

**如何编写个通用的方法，正好能够将`Employee[]`数组转换为`Object[]`数组**
**1、第一次尝试**
```java
public static Object[] badCopyOf(Object[] a, int newLength)//not useful
{
    Object[] newArray = new Object[newLength];
    System.arraycopy(a,0,newArray,0,Math.min(a.length,newLength));
    return newArray;
}
```
**问题**
* 这段代码返回的数组类型是对象数组（Object[]）类型，因为是使用如下代码创建的数组：
```java
new Object[newLength]
```
* 一个对象数组不能转换成雇员数组（Employee[]）,在运行Java时会产生ClassCastException异常。

>前面已经看到，Java 数组会记住每个元素的类型， 即创建数组时new 表达式中使用的元素类型。

>将一个Employee[] 临时地转换成Object[] 数组，然后再把它转换回来是可以的，但一从开始就是Objectt[]的数组却永远不能转换成Employe[]数组。

**（2）第二次尝试**

**为了编写这类通用的数组代码， 需要能够创建与原数组类型相同的新数组**

>需要java.lang.reflect 包中Array 类的一些方法。

>其中最关键的是Array 类中的静态方法newlnstance，它能够构造新数组。在调用它时必须提供两个参数，一个是数组的元素类型，一个是数组的长度。
```java
Object newArray = Array.newInstance(componentType, newLength);
```
（1）获取新数组的长度
* 可以通过调用Array.getLength(a) 获得数组的长度
* 也可以通过Array 类的静态getLength方法的返回值得到任意数组的长度。

（2）新数组元素类型
* 首先获得a 数组的类对象。
* 确认它是一个数组。
* 使用Class 类（只能定义表示数组的类对象）的getComponentType 方法确定数组对应的类型。

下面是这段代码：
```java
public static Object goodCopyOf(Object a, int newLength)
{
    Class cl = a.getClass();
    if(!cl.isArray()) return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newLength);
    System.arraycopy(a,0,newArray,0,Math.min(a.length,newLength));
    return newArray;
}
```
>上述CopyOf方法可以用来扩展任意类型的数组，而不仅是对象数组。

>为了能够实现这种操作，应该将goodCopyOf 的参数声明为`Object类型`，而不要声明为对象型数组（`Object[]`)。

>整型数组类型 int[]可以被转换成Object 但不能转换成对象数组。

```java
int[] a = {1,2,3,4,5};
a = (int[]) goodCopyOf(a,10);
```

```java
API java.lang.reflect.Array 1.1
    static Object get(Object array,int index)
    static xxx getXxx(Object array,int index)
        (xxx 是boolean、byte、char、double、float、int、long、short 之中的一种基本类型。）这些方法将返回存储在给定位置上的给定数组的内容。
    static void set(Object array,int index,Object newValue)
    static setXxx(Object array,int index,xxx newValue)
        (xxx 是boolean、byte、char、double、float、int、long、short 之中的一种基本类型。）这些方法将一个新值存储到给定位置上的给定数组中。
    static int getLength(Object array)
        返回数组的长度。
    static Object newInstance(Class componentType,int length)
    static Object newInstance(Class componentType,int[]lengths)
        返回一个具有给定类型、给定维数的新数组。
```
#### 5.7.6 调用任意方法

>在C 和C++ 中， 可以从函数指针执行任意函数。

>表面上看，Java 没有提供方法指针，即将一个方法的存储地址传给另外一个方法， 以便第二个方法能够随后调用它。

>事实上，Java 的设计者曾说过： 方法指针是很危险的， 并且常常会带来隐患。

>他们认为Java 提供的接口（interface ) ( 将在下一章讨论）是一种更好的解决方案。然而， **反射机制允许你调用任意方法**

>**注释**：微软公司为自己的非标准Java 语言J++（以及后来的C#）增加了另一种被称为委托（ delegate ) 的方法指针类型， 它与本节讨论的**Method类**不同。然而， 在下一章中讨论的内部类比委托更加有用。

**在Method 类中有一个invoke 方法， 它允许调用包装在当前Method 对象中的方法**
invoke方法的签名是：
```java
Object invoke(Object obj, object... args);
```
* 第一个参数是隐式参数
* 其余的对象提供了显示参数（在Java SE 5.0 以前的版本中，必须传递一个对象数组， 如果没有显式参数就传递一个null）。
* 对于静态方法，第一个参数可以被忽略， 即可以将它设置为null。

>例如， 假设用ml 代表Employee 类的getName 方法，下面这条语句显示了如何调用这个方法：
```java
String n = (String)ml.invoke(harry);
```
* 如果返回类型是基本类型， invoke 方法会返回其包装器类型。

>例如， 假设m2 表示Employee 类的getSalary 方法， 那么返回的对象实际上是一个Double，必须相应地完成类型转换。可以使用自动拆箱将它转换为一个double：
```java
double s = (Double)m2.invoke(harry);
```
**如何得到Method 对象呢？**
* 可以通过调用getDeclareMethods 方法， 然后对返回的Method 对象数组进行查找， 直到发现想要的方法为止
* 也可以通过调用Class 类中的getMethod 方法得到想要的方法。它与getField 方法类似。getField 方法根据表示域名的字符串， 返回一个Field 对象。

* 然而， 有可能存在若干个相同名字的方法， 因此要格外小心，以确保能够准确地得到想要的那个方法。

有鉴于此， 还必须提供想要的方法的参数类型。getMethod 的签名是：
```java
Method getMethod(String name, Class... parameterTypes);
```

>例如， 下面说明了如何获得Employee 类的getName 方法和raiseSalary 方法的方法指针。
```java
Method ml = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary", double.class);
```

**如何组织Method对象规则**
>到此为止，读者已经学习了使用Method 对象的规则。下面看一下如何将它们组织在一起。

>程序清单5-17 是一个打印诸如Math.sqrt、Math.sin 这样的数学函数值表的程序。

打印的结果如下所示：
```java
public static native double java.lang.Math.sqrt(double)
1.0000 | 1.0000
2.0000 | 1.4142
3.0000 | 1.7321
4.0000 | 2.0000
5.0000 | 2.2361
6.0000 | 2.4495
7.0000 | 2.6458
8.0000 | 2.8284
9.0000 | 3.0000
10.0000| 3.1623
```

当然，这段打印数学函数表格的代码与具体打印的数学函数无关。

```java
double dx = (to-from) / (n-1);
for(double x= from;x <= to;x += dx)
{
    double y = (Double) f.invoke(null,x);
    Systme.out.printf("%10.4f | %10.4f%n",x,y);
}
```
>在这里，f 是一个Method 类型的对象。由于正在调用的方法是一个静态方法，所以invoke 的第一个参数是null。

为了将Math.sqrt 函数表格化， 需要将f 设置为：
Math.class.getMethod("sqrt", double.class)

这是Math 类中的一个方法， 通过参数向它提供了一个函数名sqrt 和一个double 类型的参数。

**不建议使用Method对象**
>这种程序设计风格并不太简便，出错的可能性也比较大。如果在调用方法的时候提供了一个错误的参数，那么invoke 方法将会抛出一个异常。

>另外， invoke 的参数和返回值必须是Object 类型的。这就意味着必须进行多次的类型转换。这样做将会使编译器错过检查代码的机会。因此， 等到测试阶段才会发现这些错误， 找到并改正它们将会更加困难。

>使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。

**建议仅在必要的时候才使用Method 对象，而最好使用接口以及Java SE 8 中的lambda 表达式**（第6 章中介绍）。

>**特别要重申**： 建议Java 开发者不要使用Method 对象的回调功能。使用接口进行回调会使得代码的执行速度更快， 更易于维护。

```java
API java.lang.reflect.Method 1.1
    public Object invoke(Object implicitParameter, Object[] explicitParamenters)
        调用这个对象所描述的方法，传递给定参数，并返回方法的返回值。对于静态方法，把null作为隐式参数传递。在使用包装器传递基本类型的值时， 基本类型的返回值必须是未包装的。
```

### 5.8 继承的设计技巧

在本章的最后，给出一些对设计继承关系很有帮助的建议。

**1、将公共操作和域放在超类**

>这就是为什么将姓名域放在Person 类中，而没有将它放在Employee 和Student 类中的原因。

**2、不要使用受保护的域**

>有些程序员认为，将大多数的实例域定义为protected 是一个不错的主意， 只有这样， 子类才能够在需要的时候直接访问它们。

然而， protected 机制并不能够带来更好的保护， 其原因主要有两点。
* 第一，子类集合是无限制的， 任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected 的实例域， 从而破坏了封装性。
* 第二， 在Java 程序设计语言中，在同一个包中的所有类都可以访问proteced 域，而不管它是否为这个类的子类。

>不过，protected 方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。

**3、使用继承实现“ is-a” 关系**

使用继承很容易达到节省代码的目的，但有时候也被人们滥用了。

>例如， 假设需要定义一个钟点工类。钟点工的信息包含姓名和雇佣日期， 但是没有薪水。他们按小时计薪，并且不会因为拖延时间而获得加薪，这似乎在诱导人们由Employee 派生出子类Contractor，然后再增加一个hourlyWage 域。
```java
public class Contractor extends Employee
{
    private double hourlyWage;
    ...
}
```
* 这并不是一个好主意。因为这样一来，每个钟点对象中都包含了薪水和计时工资这两个域。在实现打印支票或税单方法的时候， 会带来无尽的麻烦， 并且与不采用继承相比， 会多写很多代码。
**钟点工与雇员之间不属于“ is-a” 关系。钟点工不是特殊的雇员**

**4、除非所有继承的方法都有意义， 否则不要使用继承**

假设想编写一个Holiday 类。每个假日也是一日，并且一日可以用`GregorianCalendar`类的实例表示，因此可以使用继承
```java
class Holiday extends CregorianCalendar { . . .}
```

* 但是，在继承的操作中， 假日集不是封闭的。在GregorianCalendar 中有一个公有方法add，可以将假日转换成非假日：
```java
Holiday christmas;
christmas.add(Calendar.DAY_OF_MONTH , 12);
```
因此，继承对于这个例子来说并不太适宜。

* 如果扩展LocalDate 就不会出现这个问题。由于这个类是不可变的， 所以没有任何方法会把假日变成非假日。

**5、在覆盖方法时， 不要改变预期的行为**

* 置换原则不仅应用于语法， 而且也可以应用于行为
* 在覆盖一个方法的时候， 不应该毫无原由地改变行为的内涵。编译器不会检查重新定义的方法是否有意义。

例如，可以重定义Holiday 类中add 方法“ 修正” 原方法的问题，或什么也不做， 或抛出一个异常， 或继续到下一个假日。

然而这些都违反了置换原则。如下语句序列
```java
int dl = x.get(Calendar.DAY_OF_MONTH);
x.add(Calendar.DAY_OF_MONTH , 1);
int d2 = x.get(Calendar.DAY_OF_HONTH);
System.out.println(d2 - dl);
```

不管x 属于GregorianCalendar 类， 还是属于Holiday 类， 执行上述语句后都应该得到预期的行为。

当然， 这样可能会引起某些争议。人们可能就预期行为的含义争论不休。例如， 有些人争论说， 置换原则要求Manager.equals 不处理bonus 域， 因为Employee.equals 没有它。

实际上， 凭空讨论这些问题毫无意义。**关键在于，在覆盖子类中的方法时，不要偏离最初的设计想法**

**6、使用多态， 而非类型信息**

无论什么时候，对于下面这种形式的代码，都应该考虑使用多态性。
```java
if (x is of type1)
    action1(x);
else if(x is of type 2)
    action2(x);
```



* action1 与action2 如果是相同的概念，就应该为这个概念定义一个方法，并将其放置在两个类的超类或接口中，然后，就可以调用
```java
x.action();
```
* 以便使用多态性提供的动态分派机制执行相应的动作

使用**多态方法或接口编写**的代码比使用对**多种类型进行检测**的代码更加**易于维护和扩展**。

**7、不要过多地使用反射**

反射机制使得人们可以通过在运行时查看域和方法， 让人们编写出更具有通用性的程序。

**这种功能对于编写系统程序来说极其实用，但是通常不适于编写应用程序**

* 反射是很脆弱的
    * 编译器很难帮助人们发现程序中的错误， 因此只有在运行时才发现错误并导致异常。


现在你已经了解了Java 支持面向对象编程的基础内容： 类、继承和多态。下一章中我们将介绍两个髙级主题：接口和lambda 表达式， 它们对于有效地使用Java 非常重要。