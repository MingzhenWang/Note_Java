<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第5章 继承](#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF)
  - [5.1 类、超类和子类](#51-%E7%B1%BB%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB)
  - [5.2 Object：所有类的超类](#52-object%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB)
  - [5.3 泛型数组列表](#53-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8)
  - [5.4 对象包装器与自动装箱](#54-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1)
  - [5.5 参数数量可变的方法](#55-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95)
  - [5.6 枚举类](#56-%E6%9E%9A%E4%B8%BE%E7%B1%BB)
  - [5.7 反射](#57-%E5%8F%8D%E5%B0%84)
  - [5.8 继承的设计技巧](#58-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


## 第5章 继承
1、本章将学习面对对象程序设计的另外一个基本概念：继承（inheritance）。

* 利用继承，人们可以基于已存在的类构造一个新类。

* 继承已存在的类就是复用（继承）这些类的方法和域，在此基础上，可以添加一些新的方法和域，以满足新的需求。

2、另外，本章还阐述了反射（reflection）的概念。

**反射**：是指在程序运行期间发现更多的类及其属性的能力。

>这是一个功能强大的特性，使用起来也比较复杂。主要是开发软件工具的人员使用，编写应用程序的人很少用到。
### 5.1 类、超类和子类

>假设在某个公司工作，这个公司中经理的待遇与普通雇员的待遇存在着一些差异。不过， 他们之间也存在着很多相同的地方， 例如， 他们都领取薪水。只是普通雇员在完成本职任务之后仅领取薪水， 而经理在完成了预期的业绩之后还能得到奖金。这种情形就需要使用继承。这是因为需要为经理定义一个新类Manager, 以便增加一些新功能。但可以重用Employee 类中已经编写的部分代码，并将其中的所有域保留下来。

>从理论上讲， 在Manager 与Employee 之间存在着明显的“ isa”（是）关系， 每个经理都是一名雇员：“ is-a” 关系是继承的一个明显特征。

#### 5.1.1 定义子类
* 下面由继承Employee类来定义Manager类的格式，关键字extends表示继承
* Manager类自动继承了超类Employee类的方法和数据域

```java
public class Manager extends Employee
{
    添加方法和域
}
```
**extends**：表明正在构造的新类派生于一个已存在的类。
* 已存在的类称为**超类（superclass）**、基类（base class）或父类（parent class）；
* 新类称为**子类（subclass）**、派生类（derived class）或孩子类（child class）。


**如何扩展超类定义子类**
* 在通过扩展超类定义子类的时候，**仅需要指出子类与超类的不同之处**
* 在设计类的时候，应该将**通用的方法放在超类中**，将具有**特殊用途的方法放在子类中

#### 5.1.2 覆盖方法
超类中的有些方法对子类Manager并不一定适用。
具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和，为此需要提供一个新的方法来覆盖（override）超类中的方法

Manager类的getSalary方法不能直接访问超类的私有域，也就是说，尽管每个Manager类的方法一定要访问私有域，但在Manager类的getSalary方法不能直接访问私有域salary。

只有Employee类的方法才能访问私有部分。

1、如果Manager类的方法一定要访问私有域，就必须借助于公有的接口。Employee类中的公有方法getSalary正式这样一个接口。
2、希望调用超类Employee中的getSalary方法，而不是当前类的方法，使用特定的关键字super解决这个问题。

Manager类中getSalary方法的正确书写格式：

public double getSalary()
{
    double baseSalary = super.getSalary();
    return baseSalary = bonus;
}

#### 5.1.3 子类构造器
在例子最后，我们来提供一个构造器。
public Manager(String name, double salary, int year, int month,int day)
{
    super(name,salary,year,month,day);
    bonus = 0;
}

这里的关键字super具有不同的含义。语句
super(name,salary,year,month,day);
	是“调用超类Employee中含有n、s、year、month和day参数的构造器”的简写形式。

由于Manager类的构造器不能访问Employee类的私有域，必须利用Employee类的构造器对这部分私有域进行初始化。
我们可以通过super实现对超类构造器的调用。
使用super调用构造器必须是子类构造器的第一条语句。

如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。
如果超类没有不带参数的构造器，且子类的构造器中没有显式地调用超类的其他构造器，则java编译器将报告错误。

注释：关键字this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。
	super关键字有两个用途：一是调用超类的方法，二是调用超类的构造器。
	
	这两个关键字的使用方式很相似：
	• 调用构造器的语句只能作为另一个构造器的第一条语句出现
	• 构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。

一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。
在运行时能够自动选择调用哪个方法的现象称为动态绑定（dynamic binding）。

#### 5.1.4 继承层次
继承并不仅限于一个层次。例如，可以由Manager类派生出Executive类。
继承层次（inheritance hierarchy）：由一个公共超类派生出来的所有类的集合。
继承链（inheritance chain）：在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。

通常，一个祖先类可以拥有多个子孙继承链。

注释：Java不支持多继承，Java中多继承功能的依靠接口实现。

#### 5.1.5 多态

使用“is-a”规则，来判断是否应该设计为继承关系，它表明子类的每个对象也是超类的对象。
例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之，不是每一名雇员都是经理。

“is-a”规则的另一种表述法：置换法则，它表明程序中出现超类对象的任何地方都可以用子类对象置换。
例如，可以将一个子类的对象赋给超类
Employee e;
e = new Employee(...);
e = new Manager(...);

在Java中，对象变量是多态的。
一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类对象。
Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0] = boss;

在上述例子中，变量staff[0]和boss引用同一个对象，但是编译器将staff[0]看做Employee对象，这意味着：
boss.setBonus(5000);//正确
staff[0].setBonus(5000);//错误
因为staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。

不能将一个超类的引用赋给子类变量。

### 5.1.6 理解方法调用
弄清楚如何在对象上应用方法调用非常重要。
下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：

1、编译器查看对象的声明类型和方法名。
	• 假设调用x.f(param)，且隐式参数x声明为C类的对象。注意：可能存在多个重载方法（名字相同参数类型不一样）。
	• 编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。
	• 至此，编译器已获取所有可能被调用的候选方法。

2、接下来，编译器将查看调用方法时提供的参数类型
	• 如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析（overloading resolution）。
	• 如果没有找到与参数类型匹配的方法，或发现经过类型转换后有多个方法与之匹配，就会报一个错误。
	• 至此，编译器已获得需要调用的方法名字和参数类型。

注释：方法的名字和参数列表称为方法的签名。
如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中这个相同签名的方法。
不过，返回类型不是签名的一部分，因此，在覆盖方法时一定要保证返回类型的兼容性。我们把这种情况称为将具有可协变返回类型。

3、静态绑定（static binding）
	• 如果是private、static、final方法或者构造器，那么编译器将准确知道应该调用哪个方法，这种调用方式称为静态绑定。
	• 与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用f(String)的指令。

4、动态绑定
	• 当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与x 所引用对象的实际类型最合适的那个类的方法。
	• 每次调用都要进行搜索，时间开支太大，因此虚拟机预先为每个类创建了一个方法表（method table），其中列出了所有方法的签名和实际调用的方法。

注释：动态绑定有一个非常重要的特性： 无需对现存的代码进行修改，就可以对程序进行扩展。
假设增加一个新类Executive, 并且Employee对象变量e 有可能引用这个类的对象， 我们不需要对包含调用e.getSalary() 的代码进行重新编译。如果e 恰好引用一个Executive 类的对象， 就会自动地调用Executive.getSalaryO 方法。

警告：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性

#### 5.1.7 阻止继承：final类和方法
不允许扩展的类被称为final类。
如果在定义类的时候使用了final修饰符就表明这个类是final类，格式如下：

public final class Executive extends MenuSelectionManager
{
    ...
}

类的特定方法被声明为final，子类就不能覆盖这个方法（final类中的所有方法自动地称为final方法）
public class Employee
{
    public final String getName()
    {
        return name;
    }
}

注释：域也可以被声明为final，final域构造对象之后不允许改变值。如果将一个类声明为final域，只有其中的方法自动地称为final，不包括域。

将方法或类声明为final 主要目的是： 确保它们不会在子类中改变语义。
	• 例如， Calendar类中的getTime 和setTime 方法都声明为final。这表明Calendar 类的设计者负责实现Date 类与日历状态之间的转换， 而不允许子类处理这些问题。
	• 同样地， String 类也是final 类，这意味着不允许任何人定义String 的子类。如果有一个String 的引用， 它引用的一定是一个String 对象， 而不可能是其他类的对象。

在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。

内联（inlining）：如果一个方法没有被覆盖并且很短，编译器就能对它进行优化处理，这个过程称为内联。
例如，内联调用e.getName()将被替换为访问e.Name域

内联的意义：
	这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略，所以被视为不受欢迎的。
内联的问题：
	如果e.getName在另外一个类中被覆盖，那编译器无法知道覆盖的代码将做什么操作，因此不能对它进行内联处理。
	
内联问题的解决：
	• 虚拟机中的即时编译器比传统的编译器的处理能力强得多，这种编译器可以准确知道类之间的继承关系，并能检测出类中是否真正存在覆盖给定的方法。
	• 如果方法很简短、被频繁调用且没有真正地被覆盖，即时编译器就会对这个方法进行内联处理。
	• 如果虚拟机加载了另外一个子类，包含了对内联方法的覆盖，优化器将取消对覆盖方法的内联，这个过程很慢，却很少发生。

#### 5.1.8 强制类型转换
第3章中，Java提供了专门用于基本数据类型 类型转换的表示法

有时，需要将某个类的对象引用转换成另外一个类的对象引用，
对象引用的转化语法：用一对圆括号将目标类名括起来，并放在需要转换的对象引用之前：
Manager boss = (Manager)staff[0];

进行类型转换的唯一原因：在暂时护士对象的实际类型之后，使用对象的全部功能。

在Java 中， 每个对象变量都属于一个类型。类型描述了这个变量所引用的以及能够引用的对象类型。
将一个子类的引用赋给一个超类变量，编译器是允许的；
将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。

如果不允许进行类型转换（超类的引用强制转换为子类的引用），Java运行时会产生ClassCastException异常。

因此类型转换前，先查看是否能够成功转换，使用instanceof操作符：
if(staff[1] instanceof Manager)
{
    boss = (Manager)staff[1];
}
如果staff[1]是null，会返回false，因为null没有引用任何对象，也不会引用Manager类型的对象。

综上所述：
	• 只能在继承层次内进行类型转换
	• 在超类转换成子类之前，应该使用instanceof进行检查

一般情况下，尽量减少使用类型转换和instanceof操作符

#### 5.1.9 抽象类
在自上而下的继承层次结构中，位于上层的类更具有通用性，甚至可能更加抽象。
从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，不作为想使用的特定的实例类。

已有Person类、Student类和Employee类，Person类为超类。一个雇员是一个人，一个学生也是一个人。

为什么要花费精力进行更高层次的抽象？
每个人都有一些诸如姓名这样的属性。学生与雇员都有姓名属性， 因此可以将getName 方法放置在位于继承关系较高层次的通用超类中。
现在， 再增加一个getDescription 方法，它可以返回对一个人的简短描述。

在Employee 类和Student 类中实现这个方法很容易。但是在Person 类中应该提供什么内容呢？ 除了姓名之外，Person 类一无所知。当然， 可以让Person.getDescription()返回一个空字符串。
然而，还有一个更好的方法， 就是使用abstract 关键字，这样就完全不需要实现这个方法了。
public abstract String getDescription();

为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。
public abstract class person
{
    ...
    public abstract String getDescription();
}

除了抽象方法之外， 抽象类还可以包含具体数据和具体方法。例如， Person 类还保存着姓名和一个返回姓名的具体方法。
public abstract class person
{
    private String name;
    public Person(String name)
    {
        this.name = name;
    }
    public abstract String getDescription();
    public String getName()
    {
        return name;
    }
}

提示：建议尽量将通用的域和方法（不管是否抽象）放在超类中（不管是否抽象）。

抽象方法充当着占位的角色，他们的具体实现在子类中。
扩展抽象类可以有两种选择：
	• 在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类。
	• 定义全部的抽象方法，这样子类就不是抽象的了。

类就是不含抽象方法，也可以将类声明为抽象类

抽象类不能被实例化，即，如果将一个类声明为abstract，就不能创建这个类的对象：
New Person("TEST")//错误

但是可以创建一个具体子类的对象，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象，例如：
Person p = new Student("Vince Vu","Economic");



#### 5.1.10 受保护访问
如果希望超类中的某些方法允许被子类访问，或者允许子类的方法访问超类的某个域，可以将这些方法或域声明为protected。

例如，如果将超类Employee中的hireDay 声明为proteced，Manager 中的方法就可以直接地访问它。
不过， Manager 类中的方法只能够访问Manager 对象中的hireDay 域， 而不能访问其他Employee 对象中的这个域。

谨慎使用protected 属性
	假设需要将设计的类提供给其他程序员使用， 而在这个类中设置了一些受保护域， 由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。在这种情况下， 如果需要对这个类的实现进行修改， 就必须通知所有使用这个类的程序员。这违背了OOP 提倡的数据封装原则。
	
受保护的方法更具有实际意义
	如果需要限制某个方法的使用， 就可以将它声明为protected。
	这表明子类（可能很熟悉祖先类）得到信任， 可以正确地使用这个方法， 而其他类则不行。

这种方法的一个最好的示例就是Object 类中的clone 方法， 有关它的详细内容请参看第6 章。


**归纳Java中控制可见性的4个访问修饰符**
* private
  * 仅对本类可见
* public
  * 对所有类可见
* protected
  * 对本包和所有子类可见
* 默认，不需要修饰符
  * 对本包可见

### 5.2 Object：所有类的超类

### 5.3 泛型数组列表

### 5.4 对象包装器与自动装箱

### 5.5 参数数量可变的方法


### 5.6 枚举类


### 5.7 反射

### 5.8 继承的设计技巧

