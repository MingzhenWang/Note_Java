<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第4章 对象与类](#%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB)
  - [4.1 面对对象程序设计概述](#41-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0)
    - [4.1.1 类](#411-%E7%B1%BB)
    - [4.1.2 对象](#412-%E5%AF%B9%E8%B1%A1)
    - [4.1.3 识别类](#413-%E8%AF%86%E5%88%AB%E7%B1%BB)
    - [4.1.4 类之间的关系](#414-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB)
  - [4.2 使用预定义类](#42-%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB)
  - [4.3 用户自定义类](#43-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB)
  - [4.4 静态域与静态方式](#44-%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E5%BC%8F)
  - [4.5 方法参数](#45-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0)
  - [4.6 对象构造](#46-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0)
  - [4.7 包](#47-%E5%8C%85)
  - [4.8 类路径](#48-%E7%B1%BB%E8%B7%AF%E5%BE%84)
  - [4.9 文档注释](#49-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A)
  - [4.10 类设计技巧](#410-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 第4章 对象与类

### 4.1 面对对象程序设计概述

1. **面对对象程序设计**（OOP，Object Oriented Programming）
   * 当今主流的程序设计范型，已经取代了20世纪70年代的“结构化”过程化程序设计开发语言。Java是完全面对对象的。

   * 面对对象的程序是由对象组成的，每个对象包含对**用户公开的特定功能部分**和**隐藏的实现部分**。

   * 程序中的很多对象来自标准库，还有一些是自定义的。在OOP中，不必关心对象的具体实现，只要能满足用户的需求即可。

2. **传统的结构化程序设计**
   * 通过设计一系列的过程（算法）来求解问题，一旦确定了这些过程，就要开始考虑存储数据的方式。

**OOP和结构化程序设计的区别**
* **结构化程序设计**：首先确定如何操作数据，然后再决定如何组织数据。
  * 对于一些规模较小的问题，将其分解为过程的开发方式比较理想

* **OOP**：将数据放在第一位，然后再考虑操作数据的算法。
  * 面对对象更加适用于解决规模较大的问题。

例如：要想实现一个简单的Web浏览器
* **面向过程**：可能需要大约2000个过程，这些过程可能需要对一组全局数据进行操作
* **面向对象**：可能只需要大约100个类，每个类平均包含20个方法。

#### 4.1.1 类
* **类（class）**：构造对象的模板或蓝图，由类构造（construct）对象的过程，称为创建**类的实例（instance）**。

  * 用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。

* **封装（encapsulation，有时称为数据隐藏）**：是与对象有关的一个重要概念。从形式上看，封装将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。

* **实例域（instance field）**：对象中的数据。
* **方法（method）**：操纵数据的过程

>对于每个特定的类实例（对象）都有一组特定的实例域值。这个值的集合就是这个对象的当前状态（state）,无论何时，只要向对象发送一个消息，它的状态就有可能改变。

* **实现封装的关键**：绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互
  * 封装给对象赋予了**黑盒特征**，这是提高**重用性**和**可靠性**的关键。

* **OOP的另一个原则**：可以通过扩展一个类来建立一个新的类。
  * 会让用户自定义Java类变得轻而易举


>在Java中，所有的类都源自一个神通广大的超类--Object。

* **继承（inheritance）**：通过扩展一个类来建立另外一个类的过程。
  * 在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于新类的新方法和数据域。


#### 4.1.2 对象
要使用OOP，一定要清楚对象的三个主要特性：
	• 对象的行为（behavior）：可以对对象施加哪些操作，或可以对对象施加哪些方法？
	• 对象的状态（state）：当施加那些方法时，对象如何响应？
	• 对象标识（identity）：如何辨别具有相同行为与状态的不同对象？

对象的行为：是用可调用的方法定义的。同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。
对象的状态：每个对象都保存着描述当前特征的信息。对象状态的改变必须通过调用方法实现（否则说明封装性遭到了破坏）。

但是，对象的状态并不能完全描述一个对象，每个对象都有一个唯一的身份（identity）。
作为一个类的实例，每个对象的标识永远是不同的，状态也常常存在差异。

#### 4.1.3 识别类
过程化程序设计：必须从顶部的main函数开始编写程序。
OOP：首先从设计类开始，然后再往每个类中添加方法。


#### 4.1.4 类之间的关系
在类之间，最常见的关系有：
	• 依赖（“users-a”）
	• 聚合（“has-a”）
	• 继承（"is-a"）

依赖（dependence），即“uses-a”关系，是一种最明显、最常见的关系，如果一个类的方法操纵另一类的对象，我们就说一个类依赖于另一类。
例如：Order类使用Account类，因为Order对象需要方法Account对象查看信用状态。
注意：应尽可能减少相互依赖的类。如果类A不知道B的存在，B的改变不会导致A产生任何bug。
用软件工程的术语来说：就是让类之间的耦合度最小。

聚合（aggregation），即“has-a”关系，聚合意味着类A的对象包含类B的对象。
例如：一个Order对象包含一些Item对象。

注释： 有些方法学家不喜欢聚合这个概念，而更加喜欢使用“ 关联” 这个术语。从建模的角度看， 这是可以理解的。但对于程序员来说，“ has-a” 显得更加形象。喜欢使用聚合的另一个理由是关联的标准符号不易区分， 请参看表4-1。


继承（inheritance），即“is-a”关系，用于表示一般与特殊关系。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。

很多程序员采用UML（Unified Modeling Language，统一建模语言）绘制类图，用来描述类之间的关系


### 4.2 使用预定义类

### 4.3 用户自定义类

### 4.4 静态域与静态方式

### 4.5 方法参数


### 4.6 对象构造


### 4.7 包


### 4.8 类路径


### 4.9 文档注释


### 4.10 类设计技巧

