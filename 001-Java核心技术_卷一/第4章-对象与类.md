<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第4章 对象与类](#%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB)
  - [4.1 面对对象程序设计概述](#41-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0)
    - [4.1.1 类](#411-%E7%B1%BB)
    - [4.1.2 对象](#412-%E5%AF%B9%E8%B1%A1)
    - [4.1.3 识别类](#413-%E8%AF%86%E5%88%AB%E7%B1%BB)
    - [4.1.4 类之间的关系](#414-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB)
  - [4.2 使用预定义类](#42-%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB)
    - [4.2.1 对象与对象变量](#421-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F)
    - [对象初始化](#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96)
    - [4.2.2 Java类库中的LocalDate类](#422-java%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84localdate%E7%B1%BB)
    - [4.2.3 更改器方法与访问器方法](#423-%E6%9B%B4%E6%94%B9%E5%99%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95)
  - [4.3 用户自定义类](#43-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB)
    - [4.3.1 Employee类](#431-employee%E7%B1%BB)
    - [4.3.2 多个源文件的使用](#432-%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8)
    - [4.3.3 剖析Employee类](#433-%E5%89%96%E6%9E%90employee%E7%B1%BB)
    - [4.3.4 构造器](#434-%E6%9E%84%E9%80%A0%E5%99%A8)
    - [4.3.5 隐式参数与显示参数](#435-%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E4%B8%8E%E6%98%BE%E7%A4%BA%E5%8F%82%E6%95%B0)
    - [4.3.6 封装的优点](#436-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9)
    - [4.3.7 基于类的访问权限](#437-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90)
    - [4.3.8 私有方法](#438-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95)
    - [4.3.9 final实例域](#439-final%E5%AE%9E%E4%BE%8B%E5%9F%9F)
  - [4.4 静态域与静态方法](#44-%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)
    - [4.4.1 静态域](#441-%E9%9D%99%E6%80%81%E5%9F%9F)
    - [4.4.2 静态常量](#442-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F)
    - [4.4.3 静态方法](#443-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)
    - [4.4.4 工厂方法](#444-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95)
    - [4.4.5 main方法](#445-main%E6%96%B9%E6%B3%95)
  - [4.5 方法参数](#45-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0)
  - [4.6 对象构造](#46-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0)
  - [4.7 包](#47-%E5%8C%85)
  - [4.8 类路径](#48-%E7%B1%BB%E8%B7%AF%E5%BE%84)
  - [4.9 文档注释](#49-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A)
  - [4.10 类设计技巧](#410-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 第4章 对象与类

### 4.1 面对对象程序设计概述

1. **面对对象程序设计**（OOP，Object Oriented Programming）
   * 当今主流的程序设计范型，已经取代了20世纪70年代的“结构化”过程化程序设计开发语言。Java是完全面对对象的。

   * 面对对象的程序是由对象组成的，每个对象包含对**用户公开的特定功能部分**和**隐藏的实现部分**。

   * 程序中的很多对象来自标准库，还有一些是自定义的。在OOP中，不必关心对象的具体实现，只要能满足用户的需求即可。

2. **传统的结构化程序设计**
   * 通过设计一系列的过程（算法）来求解问题，一旦确定了这些过程，就要开始考虑存储数据的方式。

**OOP和结构化程序设计的区别**
* **结构化程序设计**：首先确定如何操作数据，然后再决定如何组织数据。
  * 对于一些规模较小的问题，将其分解为过程的开发方式比较理想

* **OOP**：将数据放在第一位，然后再考虑操作数据的算法。
  * 面对对象更加适用于解决规模较大的问题。

例如：要想实现一个简单的Web浏览器
* **面向过程**：可能需要大约2000个过程，这些过程可能需要对一组全局数据进行操作
* **面向对象**：可能只需要大约100个类，每个类平均包含20个方法。

#### 4.1.1 类
* **类（class）**：构造对象的模板或蓝图，由类构造（construct）对象的过程，称为创建**类的实例（instance）**。

  * 用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。

* **封装（encapsulation，有时称为数据隐藏）**：是与对象有关的一个重要概念。从形式上看，封装将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。

* **实例域（instance field）**：对象中的数据。
* **方法（method）**：操纵数据的过程

>对于每个特定的类实例（对象）都有一组特定的实例域值。这个值的集合就是这个对象的当前状态（state）,无论何时，只要向对象发送一个消息，它的状态就有可能改变。

* **实现封装的关键**：绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互
  * 封装给对象赋予了**黑盒特征**，这是提高**重用性**和**可靠性**的关键。

* **OOP的另一个原则**：可以通过扩展一个类来建立一个新的类。
  * 会让用户自定义Java类变得轻而易举


>在Java中，所有的类都源自一个神通广大的超类--Object。

* **继承（inheritance）**：通过扩展一个类来建立另外一个类的过程。
  * 在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于新类的新方法和数据域。


#### 4.1.2 对象
要使用OOP，一定要清楚对象的三个主要特性：
* **对象的行为（behavior）**：可以对对象施加哪些操作，或可以对对象施加哪些方法？
  * 是用可调用的方法定义的。同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。
* **对象的状态（state）**：当施加那些方法时，对象如何响应？
  * 每个对象都保存着描述当前特征的信息。对象状态的改变必须通过调用方法实现（否则说明封装性遭到了破坏）。
* **对象标识（identity）**：如何辨别具有相同行为与状态的不同对象？
  * 对象的状态并不能完全描述一个对象，每个对象都有一个唯一的身份（identity）。

>作为一个类的实例，每个对象的标识永远是不同的，状态也常常存在差异。

#### 4.1.3 识别类
**过程化程序设计**：必须从顶部的main函数开始编写程序。
**OOP**：首先从设计类开始，然后再往每个类中添加方法。


#### 4.1.4 类之间的关系
在类之间，最常见的关系有：
* 依赖（“users-a”）
* 聚合（“has-a”）
* 继承（"is-a"）

**依赖（dependence）**
* “uses-a”关系，是一种最明显、最常见的关系，如果一个类的方法操纵另一类的对象，我们就说一个类依赖于另一类。
>例如：Order类使用Account类，因为Order对象需要方法Account对象查看信用状态。

>注意：应尽可能减少相互依赖的类。如果类A不知道B的存在，B的改变不会导致A产生任何bug。
用软件工程的术语来说：就是让类之间的耦合度最小。

**聚合（aggregation）**
* “has-a”关系，聚合意味着类A的对象包含类B的对象。例如：一个Order对象包含一些Item对象。

>注释： 有些方法学家不喜欢聚合这个概念，而更加喜欢使用“关联”这个术语。从建模的角度看， 这是可以理解的。但对于程序员来说，“ has-a” 显得更加形象。喜欢使用聚合的另一个理由是关联的标准符号不易区分， 请参看表4-1。


**继承（inheritance）**
* “is-a”关系，用于表示特殊与一般的关系。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。

>很多程序员采用**UML（Unified Modeling Language**，统一建模语言）绘制类图，用来描述类之间的关系

![](/001-Java核心技术_卷一/Pictures/4001.jpeg)

### 4.2 使用预定义类

* 在Java中没有类就无法做任何事情，并不是所有类都具有面对对象特征。


>例如：Math类。在程序中，可以使用Math类的方法，只需要使用方法名和参数，不必了解具体的实现过程（封装的关键）。

> Math类只封装了功能，不需要也不必隐藏数据，因此不必担心生成对象以及初始化实例域。

#### 4.2.1 对象与对象变量

* 要想**使用**对象，就必须**首先构造对象**，并**指定其初始状态**，然后，对对象**应用方法**。

* **构造器（constructor）**：Java使用构造器构造新实例。构造器是一种特殊的方法，用来构造并初始化对象
  * **构造器的名字与类名相同**，要想构造一个对象，需要在构造器前面加上new操作符

>例如，在标准Java库中包含一个Date类，它的对象将描述一个时间点，比如：“December 31, 1999, 23:59:59 CST”
```java
new Date()//这个表达式构造了一个新对象，这个对象被初始化为当前的日期和时间。
System.out.println(new Date());//将对象传递给一个方法
String s = new Date().toString();//Date类中有一个toString方法
```

* 如果希望构造的对象可以多次使用，需要将对象存放在一个变量（对象变量）中：
```java
Date birthday = new Date();
```

**对象与对象变量之间存在一个重要的区别**
* 对象变量不是对象，在对象变量初始化之前，不能将任何对象方法用于这个变量。
```java
Date deadLine;//deadLine没有指向任何对象
```
#### 对象初始化

1. 对象变量初始化有两个方式：
```java
//用新构造的对象初始化这个变量
deadLine = new Date();
//让这个变量引用一个已存在的对象
deadLine = birthday;
```
>注意：一个对象变量仅仅是引用一个对象，并没有实际包含一个对象。

![](/001-Java核心技术_卷一/Pictures/4002.jpeg)

* 在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用，例如：
```java
Date deadLine = new Date();
```
>表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用，这个引用存储在变量deadline中。

* 可以显示地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
* 如果将一个方法应用于一个值为null的对象上，就会产生运行时错误。
* 局部变量不会自动地初始化为null，必须通过调用new或将它们设置为null进行初始化。
  * **局部变量**：在使用前必须要初始化，否则编译报错。因为系统不会为局部变量赋默认值 
  * **全局变量**：不强制初始化，系统会根据其类型为其赋默认值：数值为0，布尔型为false，对象引用为null 

>套用《Thinking in Java》作者Bruce Eckel的话

>编译器当然可以为局部变量附一个默认值，但是未初始化的局部变量更有可能是程序员的疏忽，所以采用默认值范围会掩盖这种失误。因此强制程序员提供一个初始值，往往能够帮助找出程序里的缺陷。


#### 4.2.2 Java类库中的LocalDate类
* Date类的实例有一个状态，即**特定的时间点**。

* 时间是用距离一个固定时间点的毫秒数（可正可负）表示的，这个点就是所谓的**纪元（epoch）**，它是UTC时间1970年1月1日00:00:00。
    * UTC是Coordinated Universal Time的缩写，与GMT（Greenwich Mean Time，格林威治时间）一样，是一种具有实践意义的科学标准时间。

Date类所提供的日期处理并没有太大的用途。

>Java类库的设计者认为：像' December 31, 1999, 23:59:59" 这样的日期表示法只是阳历的固有习惯。这种特定的描述法遵循了世界上大多数地区使用的Gregorian 阳历表示法。但是，同一时间点采用中国的农历表示和采用希伯来的阴历表示就很不一样，对于火星历来说就更不可想象

**类库设计者决定将保存时间与给时间点命名分开**。所以标准Java类库分别包含了两个类：
* 一个用来表示时间点的Date类；
* 另一个用来表示大家熟悉的日历表示法的LocalDate类

>Java SE 8引入了另外一些类来处理日期和时间的不同方面，详见卷II第6章。

将时间与日历分开是一种很好的面对对象设计。通常，最好使用不同的类表示不同的概念。

**LocalDate类的使用**：
* 不要使用构造器来构造LocalDate类的对象，应该使用静态工厂方法（factory method）代表你调用构造器。
```java
LocalDate.now()//构造一个新对象，表示构造这个对象时的日期2019-12-05
LocalDate.of(1999,12,31)//提供年月日构造一个特定日期的对象
LocalDate newYearsEve = LocalDate.of(1999,12,31);//将构造的对象保存在一个对象变量中
```
* 一旦有了LocalDate对象，可以用方法getYear、getMonthValue、getDayOfMonth得到年月日：
int year = newYearsEve.getYear();//1999
int month = newYearsEve.getMonthValue();//12
int day = newYearsEve.getDayOfMonth();//31

>看起来意义不大，因为获取的值是构造对象时使用的值。不过，有时可能某个日期是计算得到的，你希望调用这些方法来获得更多的信息。

>例如：plusDays方法会得到一个新的LocalDate，如果把应用这个方法的对象称为当前对象，这个新日期对象则是距当前对象指定天数的一个新日期：
```java
LocalDate aThouandDaysLater = newYearsEve.plusDays(1000);
year = newYearsEve.getYear();//2002
month = newYearsEve.getMonthValue();//09
day = newYearsEve.getDayOfMonth();//26
```
>LocalDate类封装了实例域来维护所设置的日期。

#### 4.2.3 更改器方法与访问器方法
>上一节中的plusDays方法调用，调用之后newYearsEve的值并没有改变。

>事实上，plusDays方法会生成一个新的LocalDate对象，并把这个新对象赋予aThouandDaysLater变量。

>第3章见过的String类的toUpperCase方法具有相同特性。

**GregorianCalendar类**
* Java库的一个较早版本中有GregorianCalendar类来处理日历
* 与LocalDate.plusDays方法不同，GregorianCalendar.add方法是一个更改器方法（mutator method）,调用这个方法会改变someDay对象的状态。
```java
CregorianCalendar someDay = new CregorianCalendar(1999, 11, 31);
//Odd feature of that class: month numbers go from 0 to 11
someDay.add(Calendar.DAY_0F_M0NTH, 1000);
year = someDay.get(Calendar.YEAR); // 2002
month = someDay.get(Calendar.MONTH)+ 1; // 09
day = someDay.get(Ca1endar.DAY_0F_M0NTH); // 26
```
**更改器方法（mutator method）**：访问且可以修改对象的方法
**访问器方法（accessor method）**：只访问对象而不修改对象的方法

```java
API java.time.LocalDate 8
  static LocalTime now()
    构造一个表示当前日期的对象。
  static LocalTime of(int year,int month,int day)
    构造一个表示给定日期的对象。
  int getYear()
  int getMonthValue()
  int getDayOfMonth()
    得到当前日期的年、月和曰。
  DayOfWeek getDayOfWeek
    得到当前日期是星期几，作为DayOfWeek 类的一个实例返回。调用getValue来得到1~7 之间的一个数，1 表示星期一， 7 表示星期日。
  LocalDate plusDays(int n)
  LocalDate minusDays(int n)
    生成当前日期之后或之前n天的日期。
```

**Java 8中表示日期和时间的类有多个**，主要的有：
```java
  Instant：它代表的是时间戳，表示时刻，不直接对应年月日信息，需要通过时区转换
  LocalDateTime: 表示与时区无关的日期和时间信息，不直接对应时刻，需要通过时区转换
  LocalDate：表示与时区无关的日期，与LocalDateTime相比，只有日期信息，没有时间信息
  LocalTime：表示与时区无关的时间，与LocalDateTime相比，只有时间信息，没有日期信息
  ZonedDateTime： 表示特定时区的日期和时间
  ZoneId/ZoneOffset：表示时区
```

### 4.3 用户自定义类

* 开始学习如何设计复杂应用程序所需要的各种**主力类（workhorse class）**。
  * 通常，这些类没有main方法，却有自己的实例域和实例方法。
  * 要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个main方法。


#### 4.3.1 Employee类
* 在Java中，最简单的类定义形式为：
```java
class ClassName
{
    field1
    field2
    ...
    constructor1
    constructor2
    ...
    method1
    method2
    ...
}
```

* 下面看一个非常简单的Employee类，在编写薪金管理系统时可能会用到。
```java
public class Employee
{
    //instance fields/实例字段
    private String name;//姓名
    private double salary;//工资
    private LocalDate hireDay;//工龄
    //constructor
    public Employee(String n, double s, int year, int month, int day)
    {
        name = n;
        salary = s;
        hireDay = LocalDate.of(year, month, day);
    }
    //a method
    public String getName()
    {
        return name;
    }
    //more methods
    ...
}
```

* **源文件名必须与public类的名字相匹配**
* **在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类**

#### 4.3.2 多个源文件的使用
* 可以将每一个类存在一个单独的源文件中。

>例如，将Employee 类存放在文件Employee.java中，将EmployeeTest类存放在文件EmployeeTest.java中。

* 当Java编译器发现EmployeeTest.java使用了Employee类时会查找名为Employee.class的文件。
* 如果没有找到这个文件， 就会自动地搜索Employeejava, 然后对它进行编译。
* 如果Employee.java 版本较已有的Employee.class文件版本新，Java 编译器就会自动地重新编译这个文件。


#### 4.3.3 剖析Employee类
这个类包含一个构造器和4个方法
```java
public Employee(String n, double s, int year, int month, int day)
public String getName()
public LocalDate getHireDay()
public void raiseSalary(double byPercent)
```
包含三个实例域用来存放将要操作的数据，private确保只有Employee类自身的方法能够访问这些实例域
```java
private String name;//姓名
private double salary;//工资
private LocalDate hireDay;//工龄
```
#### 4.3.4 构造器
* 构造器与类同名，在构造Employee对象时，构造器会运行，以便将实例域初始化为所希望的状态。
* 构造器与其他的方法有一个重要的不同，构造器总是伴随着**new操作符**的执行被调用，**不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的**

**构造器知识点**
* 构造器与类同名
* 每个类可以有一个以上的构造器
* 构造器可以有0、1个或多个参数
* 构造器没有返回值
* 构造器总是伴随着new操作一起调用

>**警告**：不能在构造器中定义与实例域重名的局部变量。

#### 4.3.5 隐式参数与显示参数
方法用于操作对象以及存取它们的实例域。

>例如，如下方法将调用这个方法的对象的salary实例域设置为新值。
```java
public void raiseSalary(double byPercent)
{
    double raise = salary * byPercent /100;
    salary += raise;
}
```
* raiseSalary方法有两个参数。
  * 第一个参数称为**隐式（implicit）参数**，是出现在方法名前的Employee对象。有人把隐式参数称为**方法调用的目标或接收者**。
  * 第二个参数称为**显示（explicit）参数**，位于方法名后面括号中的数值。

>在每一个方法中，关键字this表示隐式参数，如果需要的话，可以用下列方式编写raiseSalary方法：
```java
public void raiseSalary(double byPercent)
{
    double raise = this.salary * byPercent /100;
    this.salary += raise;
}
```
**这种写法可以将实例域与局部变量明显地区分开来**

>在java中，所有的类必须定义在方法内部，是否将某个方法设置为**内联方法**是Java虚拟机的任务。

>即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。

#### 4.3.6 封装的优点
```java
public String getName()
{
    return name;
}
public double getSalary()
{
    return salary;
}
public LocalDate getHireDay()
{
    return hireDay;
}
```
**域访问器**：上述方法都是典型的访问器方法，由于它们只返回实例域值，因此又称为域访问器。

1. **不能将name、salary域标记为public**

* name是一个只读域，一旦在构造域中设置完毕，就没有任何一个办法可以对它进行修改，这样来确保name域不会受到外界的破坏。
* 虽然salary不是只读域，但是只能用raiseSalary方法修改。一旦这个预置出现错误，只需调试这个方法即可。

2. **需要获得或设置实例域的值，应该提供下面三项内容**：
   * 一个私有的数据域
   * 一个公有的域访问器方法
   * 一个公有的域更改器方法

3. **这样做更复杂，但是却有如下明显的好处**：
* 可以改变内部实现，除了该类的方法外，不会影响其他代码。
* 更改器方法可以执行错误检查，然而直接对这些域进行赋值不会进行这些处理，比如，setSalary方法可以检查薪金是否小于0

4. **不要编写返回引用可变对象的访问器方法**。

例如：在Employee类中就违反了这个涉及原则，其中的getHireDay方法返回了一个Date类对象
```java
class Employee
{
    private Date hireDay;
    public Date getHireDay()
    {
        return hireDay;
    }
    ...
}

Employee harry = ...;
//d和hireDay引用同一对象，对d调用更改器方法就可以自动改变这个雇员对象的私有状态
Date d = harry.getHireDay();
doubel tenYearsInMilliSeconds = 10 * 365.25 * 24 * 60 * 60 *1000;
//修改d的毫秒数，会同步修改harry的hireday时间
d.setTime(d.getTime()-(long)tenYearsInMilliSeconds); 
```
>LocalDate没有更改器方法，但是Date类有一个更改器方法setTime，可以设置毫秒数。
>Date对象是可变的，这一点就破坏了封装性！

![](/001-Java核心技术_卷一/Pictures/4003.jpeg)


5. **如果需要返回一个可变对象的引用，应该首先对它进行克隆(clone)**

* 对象的克隆是指存放在另一个位置的对象副本
* 如果需要返回一个可变数据域的拷贝，就应该使用clone

```java
class Employee
{
    private Date hireDay;
    public Date getHireDay()
    {
        return (Date)hireDay.clone();
    }
    ...
}
```

#### 4.3.7 基于类的访问权限
* 方法可以访问所调用对象的私有数据
* 方法可以访问所属类的所有对象的私有数据

#### 4.3.8 私有方法
1. **数据域的访问权限**
   * 由于公有数据非常危险，应该将所有的数据域都设置为私有的

1. **方法的访问权限**
   * 大多数方法都被设计成公有的
   * 某些特殊情况下，可以将它们设置成私有的
     * 例如，如果将一个方法分成若干个独立的辅助方法，这些辅助方法应该设计为private。

   * 私有的方法不会被外部的其他类操作调用，可以将其删去
   * 公有的方法不能随便删除，因为其他的代码很有可能依赖它

#### 4.3.9 final实例域
* 可以将实例域定义为final，**构建对象时必须初始化这样的域**。
  * 即，必须确保在每个构造器执行之后，这个域的值被设置，并且之后不能对它进行修改。

>例如，可以将Employee类的name域声明为final，因为在对象构建之后，这个值不会再被修改，即没有setName方法
```java
class Employee
{
  private final String name;
  ...
}
```

* final修饰符大都应用于**基本（primitive）类型域**(例如int)，或**不可变类（immutable）的域**。
* **不可变类**：如果类中的每个方法都不会改变对象，这种类就是不可变的类，例如String类就是一个不可变的类。


**对于可变的类，使用final修饰符可能会对读者造成混乱**，例如：
```java
private final StringBuilder evaluations;
```

1. 在Employee构造器中会初始化为：
```java

evaluations = new StringBuilder();
```

2. final关键字只是表示**存储在evaluations变量中的对象引用不会再指示其他StringBuilder对象**。不过这个对象可以更改：
```java
public void giveGoldStar()
{
    evaluations.append(LocalDate.now() + "：Gold Star！\n");
}
```

### 4.4 静态域与静态方法

* main方法会被标记为static修饰符，静态修饰符
#### 4.4.1 静态域
* 如果将域定义为static，**每个类中只有一个这样的域**。
  * 可以有多个静态的变量，但是不管你New出这个类的多少个对象，所有的对象都共享这一个静态的变量，与多少个对象无关
* 而每一个对象对于所有的实例域却都有自己的一份拷贝。
* 静态域属于类，不属于任何独立的对象。
>例如：假如需要给每一个雇员赋予唯一的标识码，这里给Employee类添加一个实例域id和一个静态域nextId

>现在，每一个雇员对象都有一个自己的id域，但是这个类的所有实例将共享一个nextId域。

>如果有1000个Employee类的对象，则有1000个实例域id，但是只有一个静态域nextId。即使没有一个雇员对象，静态域nextId也存在。
```java
class Employee
{
    private static int nextId = 1;
    private int id;
    ...
}
```


#### 4.4.2 静态常量
* 静态变量用的比较少，但静态常量使用的比较多
>例如，在Math类中定义了一个静态变量：
```java
public class Math
{
    public static final double PI = 3.141592653589;
}
```
* 静态常量，可以采用Math.PI的形式获取这个常量。
* 如果关键字static被省略，PI就变成了**Math类的一个实例域**。需要通过Math类的对象访问PI，并且每一个Math对象都有它自己的一份PI拷贝。

>另一个多次使用的静态常量是System.out。它在System类中声明。
```java
public class Systme
{
    public static final PrintStream out = ...;
}
```

* 由于每个类对象都可以对公有域进行修改，所以，最好不要将域设计为public。
* 但是，公有常量（即final域）却没问题（对象被构建后，值不会再被修改）。
* 因为out被声明为final，所以不允许再将其他打印流赋给它：
```java
System.out = new PrintStream(...);//Error--out is final
```
>注意：System类有一个**setOut方法**，它可以将System.out设置为不同的流。

>为什么这个方法可以修改final变量的值？
因为，**setOut是一个本地方法**，不是用Java语言实现的，本地方法可以绕过Java语言的存取控制机制，这是一种特殊的方法。


#### 4.4.3 静态方法
* **静态方法**：是一种不能向对象实施操作的方法。

>例如：Math类的pow方法就是一个静态方法，Math.pow(x,a)计算幂Xa。在运算时，不使用Math对象，即没有隐式的参数。

* 可以认为**静态方法是没有this参数的方法**，在非静态的方法中，this参数表示这个方法的隐式参数。

* 静态方法可以访问**自身的静态域**
>例如，Employee类的静态方法不能访问Id实例域，因为它不能操作对象。但是静态方法可以访问自身类的静态域。示例如下：
```java
public static int getNextId()
{
    return nextId;//返回静态域
}
//可以通过类名调用这个方法
int n = Employee.getNextId();
```


>注释：可以使用对象调用静态方法。
例如，如果Harry是一个Employee对象，可以用Harry.getNextId()代替Employee.getNextId()
不过这种方式很容易造成混淆，其原因是getNextId方法计算的结果与Harry毫无关系。

**建议使用类名，而不是对象来调用静态方法**

**在以下两种情况下使用静态方法**:
* 一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（例如：Math.pow）
* 一个方法只需要访问类的静态域（例如：Employee.getNextId）

#### 4.4.4 工厂方法
* 是一种对象创建型模式
* 工厂方法的目的：使得创建对象和使用对象是分离的
  * 定义一个用于创建对象的接口，但是让子类来决定到底创建哪一个实例。工厂方法模式让一个类的实例化延迟到其子类。


* 静态方法还有另外一种常见的用途：**使用静态工厂方法（factor method）来构造对象**
  * 类似LocalDate和NumberFormat的类

* NumberFormat类使用如下工厂犯法生成不同风格的格式化对象
```java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
NumberFormat percentFormatter = NumberFormat.getPercentInstance();
double x = 0.1;
System.out.println(currencyFormatter.format(x));//prints $0.10
System.out.println(percentFormatter.format(x));//prints 10%
```
**为什么NumberFormat类不利用构造器完成这些操作？**
* **无法命名构造器**
  * 构造器的名字必须与类名相同，但是这里希望得到的货币实例和百分比实例采用不同的名字。
* **当使用构造器时，无法改变所构造的对象类型**
  * Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类

#### 4.4.5 main方法
>注意，不需要使用对象调用静态方法。例如，不需要构造Math类对象就可以调用Math.pow

* main方法也是一个静态方法。
```java
public class Application
{
    public static void main(String[] args)
    {
        //construct obejcts here
        ...
    }
}
```
* main方法不对任何对象进行操作
* 在启用程序时还没有任何一个对象
* 静态的main方法将执行并创建程序所需的对象。

### 4.5 方法参数

* **按值调用（call by value）**：表示方法接收的是调用者提供的值
* **按引用调用（call by reference）**：表示方法接收的是调用者提供的变量地址。

一个方法**可以修改传递引用**所对应的**变量值**，而**不能修改**传递**值调用**所对应的**变量值**。

* **Java总是采用按值调用**
  * 即方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。

**方法参数共有两种类型**：
* 基本数据类型（数字、布尔值）
* 对象引用

**一个方法不可能修改一个基本数据类型的参数，但是可以修改对象引用的参数。**

1. 基本数据类型参数--示例
>假定一个方法视图将一个参数增加至3倍
```java
public static void tripleValue(double x)//不生效
{
    x = 3 * x;
}
double percent = 10;
tripleValue(percent);
```
>该方法并不生效，调用之后，percent的值依然是10。具体执行过程如下：
1. x被初始化为percent值的一个拷贝（也就是10）；
2. x被乘以3后等于30，但是percent仍然是10；
3. 这个方法结束后，参数x不再使用

![](/001-Java核心技术_卷一/Pictures/4004.jpeg)


2. 对象引用参数--示例
>可以使用如下方法将一个雇员的薪金提高两倍：
```java
public static void tripleSalary(Employee x)//生效
{
    x.raiseSalary(200);
}
harry = new Employee(...);
tripleSalary(harry);
```
>具体执行过程为：
1. x被初始化为Harry值的拷贝，这是一个对象的引用；
2. raiseSalary方法应用于这个对象引用。x和harry同时引用的Employee对象的薪金提高了200%；
3. 方法结束后，参数变量x不再使用。对象变量harry继续引用薪金增至3倍的雇员对象。

![](/001-Java核心技术_卷一/Pictures/4005.jpeg)

**Java对对象采用的不是引用调用，对象引用是按照值传递的**。

**Java中方法参数的使用**
* 一个方法不能修改一个基本数据类型的参数（即数值或布尔型）
* 一个方法可以改变一个对象参数的状态
* 一个方法不能让对象参数引用一个新的对象


### 4.6 对象构造


### 4.7 包


### 4.8 类路径


### 4.9 文档注释


### 4.10 类设计技巧

