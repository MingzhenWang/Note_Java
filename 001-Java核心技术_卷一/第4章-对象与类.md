<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [第4章 对象与类](#%E7%AC%AC4%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB)
  - [4.1 面对对象程序设计概述](#41-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0)
    - [4.1.1 类](#411-%E7%B1%BB)
    - [4.1.2 对象](#412-%E5%AF%B9%E8%B1%A1)
    - [4.1.3 识别类](#413-%E8%AF%86%E5%88%AB%E7%B1%BB)
    - [4.1.4 类之间的关系](#414-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB)
  - [4.2 使用预定义类](#42-%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB)
  - [4.3 用户自定义类](#43-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB)
  - [4.4 静态域与静态方式](#44-%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E5%BC%8F)
  - [4.5 方法参数](#45-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0)
  - [4.6 对象构造](#46-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0)
  - [4.7 包](#47-%E5%8C%85)
  - [4.8 类路径](#48-%E7%B1%BB%E8%B7%AF%E5%BE%84)
  - [4.9 文档注释](#49-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A)
  - [4.10 类设计技巧](#410-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 第4章 对象与类

### 4.1 面对对象程序设计概述

1. **面对对象程序设计**（OOP，Object Oriented Programming）
   * 当今主流的程序设计范型，已经取代了20世纪70年代的“结构化”过程化程序设计开发语言。Java是完全面对对象的。

   * 面对对象的程序是由对象组成的，每个对象包含对**用户公开的特定功能部分**和**隐藏的实现部分**。

   * 程序中的很多对象来自标准库，还有一些是自定义的。在OOP中，不必关心对象的具体实现，只要能满足用户的需求即可。

2. **传统的结构化程序设计**
   * 通过设计一系列的过程（算法）来求解问题，一旦确定了这些过程，就要开始考虑存储数据的方式。

**OOP和结构化程序设计的区别**
* **结构化程序设计**：首先确定如何操作数据，然后再决定如何组织数据。
  * 对于一些规模较小的问题，将其分解为过程的开发方式比较理想

* **OOP**：将数据放在第一位，然后再考虑操作数据的算法。
  * 面对对象更加适用于解决规模较大的问题。

例如：要想实现一个简单的Web浏览器
* **面向过程**：可能需要大约2000个过程，这些过程可能需要对一组全局数据进行操作
* **面向对象**：可能只需要大约100个类，每个类平均包含20个方法。

#### 4.1.1 类
* **类（class）**：构造对象的模板或蓝图，由类构造（construct）对象的过程，称为创建**类的实例（instance）**。

  * 用Java编写的所有代码都位于某个类的内部。标准的Java库提供了几千个类，可以用于用户界面设计、日期、日历和网络程序设计。

* **封装（encapsulation，有时称为数据隐藏）**：是与对象有关的一个重要概念。从形式上看，封装将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。

* **实例域（instance field）**：对象中的数据。
* **方法（method）**：操纵数据的过程

>对于每个特定的类实例（对象）都有一组特定的实例域值。这个值的集合就是这个对象的当前状态（state）,无论何时，只要向对象发送一个消息，它的状态就有可能改变。

* **实现封装的关键**：绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互
  * 封装给对象赋予了**黑盒特征**，这是提高**重用性**和**可靠性**的关键。

* **OOP的另一个原则**：可以通过扩展一个类来建立一个新的类。
  * 会让用户自定义Java类变得轻而易举


>在Java中，所有的类都源自一个神通广大的超类--Object。

* **继承（inheritance）**：通过扩展一个类来建立另外一个类的过程。
  * 在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于新类的新方法和数据域。


#### 4.1.2 对象
要使用OOP，一定要清楚对象的三个主要特性：
* **对象的行为（behavior）**：可以对对象施加哪些操作，或可以对对象施加哪些方法？
  * 是用可调用的方法定义的。同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。
* **对象的状态（state）**：当施加那些方法时，对象如何响应？
  * 每个对象都保存着描述当前特征的信息。对象状态的改变必须通过调用方法实现（否则说明封装性遭到了破坏）。
* **对象标识（identity）**：如何辨别具有相同行为与状态的不同对象？
  * 对象的状态并不能完全描述一个对象，每个对象都有一个唯一的身份（identity）。

>作为一个类的实例，每个对象的标识永远是不同的，状态也常常存在差异。

#### 4.1.3 识别类
**过程化程序设计**：必须从顶部的main函数开始编写程序。
**OOP**：首先从设计类开始，然后再往每个类中添加方法。


#### 4.1.4 类之间的关系
在类之间，最常见的关系有：
* 依赖（“users-a”）
* 聚合（“has-a”）
* 继承（"is-a"）

**依赖（dependence）**
* “uses-a”关系，是一种最明显、最常见的关系，如果一个类的方法操纵另一类的对象，我们就说一个类依赖于另一类。
>例如：Order类使用Account类，因为Order对象需要方法Account对象查看信用状态。

>注意：应尽可能减少相互依赖的类。如果类A不知道B的存在，B的改变不会导致A产生任何bug。
用软件工程的术语来说：就是让类之间的耦合度最小。

**聚合（aggregation）**
* “has-a”关系，聚合意味着类A的对象包含类B的对象。例如：一个Order对象包含一些Item对象。

>注释： 有些方法学家不喜欢聚合这个概念，而更加喜欢使用“关联”这个术语。从建模的角度看， 这是可以理解的。但对于程序员来说，“ has-a” 显得更加形象。喜欢使用聚合的另一个理由是关联的标准符号不易区分， 请参看表4-1。


**继承（inheritance）**
* “is-a”关系，用于表示特殊与一般的关系。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。

>很多程序员采用**UML（Unified Modeling Language**，统一建模语言）绘制类图，用来描述类之间的关系

![](/001-Java核心技术_卷一/Pictures/4001.jpeg)

### 4.2 使用预定义类

* 在Java中没有类就无法做任何事情，并不是所有类都具有面对对象特征。


>例如：Math类。在程序中，可以使用Math类的方法，只需要使用方法名和参数，不必了解具体的实现过程（封装的关键）。

> Math类只封装了功能，不需要也不必隐藏数据，因此不必担心生成对象以及初始化实例域。

#### 4.2.1 对象与对象变量

* 要想**使用**对象，就必须**首先构造对象**，并**指定其初始状态**，然后，对对象**应用方法**。

在Java中，使用构造器（constructor）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象
例如，在标准Java库中包含一个Date类，它的对象将描述一个时间点，比如：“December 31, 1999, 23:59:59 CST”
构造器的名字应该与类名相同，因此Date类的构造器名为Date。要想构造一个Date对象，需要在构造器前面加上new操作符：
new Date()//这个表达式构造了一个新对象，这个对象被初始化为当前的日期和时间。
System.out.println(new Date);//将对象传递给一个方法
String s = new Date().toString();//Date类中有一个toString方法

如果希望构造的对象可以多次使用，需要将对象存放在一个变量（对象变量）中：
Date birthday = new Date();

对象与对象变量之间存在一个重要的区别：对象变量不是对象，在对象变量初始化之前，不能将任何对象方法用于这个变量。
Date deadLine;//deadLine没有指向任何对象

对象变量初始化有两个方式：
用新构造的对象初始化这个变量：deadLine = new Date();
让这个变量引用一个已存在的对象：deadLine = birthday;

注意：一个对象变量仅仅是引用一个对象，并没有实际包含一个对象。

在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用，例如：
Date deadLine = new Date();

表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用，这个引用存储在变量deadline中。

可以显示地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。
如果将一个方法应用于一个值为null的对象上，就会产生运行时错误。
局部变量不会自动地初始化为null，必须通过调用new或将它们设置为null进行初始化。
局部变量：在使用前必须要初始化，否则编译报错。因为系统不会为局部变量赋默认值 
全局变量：不强制初始化，系统会根据其类型为其赋默认值：数值为0，布尔型为false，对象引用为null 

套用《Thinking in Java》作者Bruce Eckel的话

编译器当然可以为局部变量附一个默认值，但是未初始化的局部变量更有可能是程序员的疏忽，所以采用默认值范围会掩盖这种失误。因此强制程序员提供一个初始值，往往能够帮助找出程序里的缺陷。


#### 4.2.2 Java类库中的LocalDate类
Date类的实例有一个状态，即特定的时间点。

时间是用距离一个固定时间带你的毫秒数（可正可负）表示的，这个点就是所谓的纪元（epoch），
它是UTC时间1970年1月1日00:00:00。
UTC是Coordinated Universal Time的缩写，与GMT（Greenwich Mean Time，格林威治时间）一样，是一种具有实践意义的科学标准时间。

Date类所提供的日期处理并没有太大的用途。
Java类库的设计者认为：像' December 31, 1999, 23:59:59" 这样的日期表示法只是阳历的固有习惯。这种特定的描述法遵循了世界上大多数地区使用的Gregorian 阳历表示法。但是，同一时间点采用中国的农历表示和采用希伯来的阴历表示就很不一样，对于火星历来说就更不可想象
类库设计者决定将保存时间与给时间点命名分开。所以标准Java类库分别包含了两个类：
	• 一个用来表示时间点的Date类；
	• 另一个用来表示大家熟悉的日历表示法的LocalDate类
Java SE 8引入了另外一些类来处理日期和时间的不同方面，详见卷II第6章。

将时间与日历分开是一种很好的面对对象设计。通常，最好使用不同的类表示不同的概念。

LocalDate类的使用：
不要使用构造器来构造LocalDate类的对象，应该使用静态工厂方法（factory method）代表你调用构造器。
LocalDate.now()//构造一个新对象，表示构造这个对象时的日期2019-12-05
LocalDate.of()//提供年月日构造一个特定日期的对象
LocalDate newYearsEve = LocalDate.of(1999,12,31);//将构造的对象保存在一个对象变量中

一旦有了LocalDate对象，可以用方法getYear、getMonthValue、getDayOfMonth得到年月日：
int year = newYearsEve.getYear();//1999
int month = newYearsEve.getMonthValue();//12
int day = newYearsEve.getDayOfMonth();//31

看起来意义不大，因为获取的值是构造对象时使用的值。不过，有时可能某个日期是计算得到的，你希望调用这些方法来获得更多的信息。
例如：plusDays方法会得到一个新的LocalDate，如果把应用这个方法的对象称为当前对象，这个新日期对象则是距当前对象指定天数的一个新日期：
LocalDate aThouandDaysLater = newYearsEve.plusDays(1000);
year = newYearsEve.getYear();//2002
month = newYearsEve.getMonthValue();//09
day = newYearsEve.getDayOfMonth();//26

LocalDate类封装了实例域来维护所设置的日期。

#### 4.2.3 更改器方法与访问器方法
上一节中的plusDays方法调用，调用之后newYearsEve的值并没有改变。
事实上，plusDays方法会生成一个新的LocalDate对象，并把这个新对象赋予aThouandDaysLater变量。
第3章见过的String类的toUpperCase方法具有相同特性。

Java库的一个较早版本中有GregorianCalendar类来处理日历，与LocalDate.plusDays方法不同，GregorianCalendar.add方法是一个更改器方法（mutator method）,调用这个方法会改变someDay对象的状态。

CregorianCalendar someDay = new CregorianCalendar(1999, 11, 31);
//Odd feature of that class: month numbers go from 0 to 11
someDay.add(Calendar.DAY_0F_M0NTH, 1000);
year = someDay.get(Calendar.YEAR); // 2002
month = someDay.get(Calendar.MONTH)+ 1; // 09
day = someDay.get(Ca1endar.DAY_0F_M0NTH); // 26

相反，只访问对象而不修改对象的方法有时称为访问器方法（accessor method）。

API java.time.LocalDate 8
	• static LocalTime now()
		○ 构造一个表示当前日期的对象。
	• static LocalTime of(int year,int month,int day)
		○ 构造一个表示给定日期的对象。
	• int getYear()
	• int getMonthValue()
	• int getDayOfMonth()
		○ 得到当前日期的年、月和曰。
	• DayOfWeek getDayOfWeek
		○ 得到当前日期是星期几，作为DayOfWeek 类的一个实例返回。调用getValue来得到1~7 之间的一个数，1 表示星期一， 7 表示星期日。
	• LocalDate piusDays(int n)
	• LocalDate minusDays(int n)
		○ 生成当前日期之后或之前n天的日期。


Java 8中表示日期和时间的类有多个，主要的有：
	• Instant：它代表的是时间戳，表示时刻，不直接对应年月日信息，需要通过时区转换
	• LocalDateTime: 表示与时区无关的日期和时间信息，不直接对应时刻，需要通过时区转换
	• LocalDate：表示与时区无关的日期，与LocalDateTime相比，只有日期信息，没有时间信息
	• LocalTime：表示与时区无关的时间，与LocalDateTime相比，只有时间信息，没有日期信息
	• ZonedDateTime： 表示特定时区的日期和时间
	• ZoneId/ZoneOffset：表示时区


### 4.3 用户自定义类

### 4.4 静态域与静态方式

### 4.5 方法参数


### 4.6 对象构造


### 4.7 包


### 4.8 类路径


### 4.9 文档注释


### 4.10 类设计技巧

